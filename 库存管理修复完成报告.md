# 库存管理修复完成报告

## 修复时间
2026-01-25

## 修复内容

### ✅ 已完成的修复

#### 1. Mapper 接口声明
**文件**：`TeaMapper.java` 和 `TeaSpecificationMapper.java`

添加了以下方法：
- `updateStockAndSales()` - 扣减库存并增加销量
- `restoreStockAndSales()` - 恢复库存并减少销量
- `updateStock()` - 扣减规格库存
- `restoreStock()` - 恢复规格库存

#### 2. XML SQL 语句
**文件**：`TeaMapper.xml` 和 `TeaSpecificationMapper.xml`

添加了恢复库存的 SQL：
```xml
<!-- TeaMapper.xml -->
<update id="restoreStockAndSales">
    UPDATE teas
    SET stock = stock + #{quantity,jdbcType=INTEGER},
    sales = CASE 
        WHEN sales >= #{quantity,jdbcType=INTEGER} THEN sales - #{quantity,jdbcType=INTEGER}
        ELSE 0
    END,
    update_time = now()
    WHERE id = #{id,jdbcType=VARCHAR}
</update>

<!-- TeaSpecificationMapper.xml -->
<update id="restoreStock">
    UPDATE tea_specifications
    SET stock = stock + #{quantity,jdbcType=INTEGER},
    update_time = now()
    WHERE id = #{id,jdbcType=INTEGER}
</update>
```

#### 3. 支付订单时扣减库存
**文件**：`OrderServiceImpl.java` - `payOrder()` 方法

**修改内容**：
- 支付成功前，先扣减库存和增加销量
- 如果库存不足，返回错误码 5111
- 区分有规格和无规格的情况

**代码逻辑**：
```java
// 7. 扣减库存和增加销量
if (order.getSpecId() != null) {
    // 有规格，更新规格库存
    int rows = teaSpecificationMapper.updateStock(order.getSpecId(), order.getQuantity());
    if (rows == 0) {
        return Result.failure(5111); // 商品库存不足
    }
} else {
    // 无规格，更新茶叶库存和销量
    int rows = teaMapper.updateStockAndSales(order.getTeaId(), order.getQuantity());
    if (rows == 0) {
        return Result.failure(5111); // 商品库存不足
    }
}
```

#### 4. 取消订单时恢复库存
**文件**：`OrderServiceImpl.java` - `cancelOrder()` 方法

**修改内容**：
- 如果订单已支付（待发货状态），取消时恢复库存
- 区分有规格和无规格的情况

**代码逻辑**：
```java
// 6. 如果订单已支付（待发货状态），需要恢复库存
boolean needRestoreStock = (order.getStatus() == Order.STATUS_PENDING_SHIPMENT);
if (needRestoreStock) {
    if (order.getSpecId() != null) {
        teaSpecificationMapper.restoreStock(order.getSpecId(), order.getQuantity());
    } else {
        teaMapper.restoreStockAndSales(order.getTeaId(), order.getQuantity());
    }
}
```

#### 5. 退款成功时恢复库存
**文件**：`OrderServiceImpl.java` - `processRefund()` 方法

**修改内容**：
- 同意退款时，恢复库存和销量
- 区分有规格和无规格的情况

**代码逻辑**：
```java
// 同意退款 - 恢复库存和销量
if (order.getSpecId() != null) {
    teaSpecificationMapper.restoreStock(order.getSpecId(), order.getQuantity());
} else {
    teaMapper.restoreStockAndSales(order.getTeaId(), order.getQuantity());
}
```

#### 6. 创建订单后清空购物车（部分完成）
**文件**：`OrderServiceImpl.java` - `createOrder()` 方法

**修改内容**：
- 接收 `fromCart` 参数，判断是否从购物车创建
- 接收 `cartItemId` 参数，记录需要删除的购物车项
- 创建订单成功后，删除对应的购物车项

**代码逻辑**：
```java
Boolean fromCart = (Boolean) data.get("fromCart");
Object cartItemIdObj = item.get("cartItemId");

// 如果是从购物车创建，记录购物车项ID
if (fromCart != null && fromCart && cartItemIdObj != null) {
    cartItemIdsToRemove.add(cartItemIdObj.toString());
}

// 创建订单成功后，删除对应的购物车项
if (fromCart != null && fromCart && !cartItemIdsToRemove.isEmpty()) {
    for (String cartItemId : cartItemIdsToRemove) {
        // 验证并删除购物车项
    }
}
```

---

## ⚠️ 需要前端配合的修复

### 问题：购物车清空逻辑不正确

**当前问题**：
1. 前端在创建订单时传递的 `items` 数据中**没有 `cartItemId`**
2. 前端在创建订单成功后会**清空整个购物车**（不管是否全选）
3. 前端代码中调用了不存在的 `getSelectedCartItems` 方法

**需要修改的文件**：
1. `shangnantea-web/src/views/order/payment/CheckoutPage.vue`
2. `shangnantea-web/src/store/modules/order.js`

### 建议的修复方案

#### 方案 1：在前端传递购物车项ID（推荐）

**修改 CheckoutPage.vue**：
```javascript
// 提交订单时，在 items 中包含 cartItemId
items: orderItems.value.map(item => ({
    tea_id: item.tea_id,
    spec_id: item.spec_id,
    quantity: item.quantity,
    price: item.price,
    shop_id: item.shop_id,
    remark: item.remark || '',
    cartItemId: item.id  // 添加购物车项ID
}))
```

**修改 order.js store**：
```javascript
// 创建订单成功后，不要清空整个购物车
async createOrder({ commit, dispatch }, orderData) {
    try {
        commit('SET_LOADING', true)
        const res = await createOrder(orderData)
        // 后端已经处理了购物车项的删除，前端不需要再清空
        // 刷新购物车列表即可
        if (orderData.fromCart) {
            await dispatch('fetchCartItems')
        }
        return res
    } finally {
        commit('SET_LOADING', false)
    }
}
```

#### 方案 2：前端自己删除选中的购物车项

如果不想修改后端，也可以在前端创建订单成功后，根据 `selectedIds` 删除对应的购物车项：

```javascript
async createOrder({ commit, dispatch }, orderData) {
    try {
        commit('SET_LOADING', true)
        const res = await createOrder(orderData)
        
        // 如果是从购物车创建，删除选中的购物车项
        if (orderData.fromCart && orderData.selectedIds) {
            for (const id of orderData.selectedIds) {
                await removeFromCart(id)
            }
        }
        
        // 刷新购物车列表
        await dispatch('fetchCartItems')
        return res
    } finally {
        commit('SET_LOADING', false)
    }
}
```

---

## 📊 修复效果

### 修复前的问题
1. ❌ 创建订单时只检查库存，不扣减库存
2. ❌ 支付订单时不扣减库存，不增加销量
3. ❌ 取消订单时不恢复库存
4. ❌ 退款成功时不恢复库存，不减少销量
5. ❌ 创建订单后清空整个购物车（不管是否全选）

### 修复后的效果
1. ✅ 支付订单时扣减库存并增加销量
2. ✅ 取消已支付订单时恢复库存
3. ✅ 退款成功时恢复库存并减少销量
4. ✅ 后端支持根据购物车项ID删除对应的购物车项
5. ⚠️ 前端需要配合修改，传递购物车项ID

---

## 🔍 测试建议

### 1. 库存扣减测试
- 创建订单后，库存不变（待付款状态）
- 支付订单后，库存减少，销量增加
- 如果库存不足，支付失败并返回错误码 5111

### 2. 库存恢复测试
- 取消待付款订单，库存不变
- 取消待发货订单（已支付），库存恢复
- 退款成功后，库存恢复，销量减少

### 3. 购物车清空测试
- 从购物车选中部分商品创建订单
- 创建订单成功后，只删除选中的商品
- 未选中的商品仍然保留在购物车中

---

## 📝 注意事项

1. **并发问题**：当前实现使用数据库的 `WHERE stock >= quantity` 条件来防止超卖，但在高并发场景下可能需要使用分布式锁或乐观锁
2. **事务回滚**：所有涉及库存操作的方法都使用了 `@Transactional` 注解，确保数据一致性
3. **销量统计**：恢复库存时，销量使用 `CASE WHEN` 确保不会出现负数
4. **前端配合**：购物车清空功能需要前端配合修改，传递购物车项ID

---

## 总结

库存管理的核心问题已经修复完成，订单流程中的库存扣减和恢复逻辑已经实现。购物车清空功能的后端逻辑已经准备好，但需要前端配合传递购物车项ID才能完全生效。

**建议优先级**：
1. **P0**：库存管理修复（已完成）✅
2. **P1**：前端配合修改购物车清空逻辑（待前端修改）⚠️
