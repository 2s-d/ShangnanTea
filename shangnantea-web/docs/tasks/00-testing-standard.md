# 测试章程 - 商南茶文化平台前端测试标准

## 文档说明

本文档定义了项目测试的标准流程、方法和验收标准。所有任务分解文档中的"检查测试"部分必须遵循本章程。

**版本**: 3.0  
**创建日期**: 2024-12-17  
**最后更新**: 2024-12-17  
**状态**: 生效中

---

## 一、项目开发与测试流程

### 1.1 开发流程（以任务分解文档为纲领）

```
1. 查看任务分解文档（docs/tasks/0X-[模块名]-module-tasks.md）
   ↓
2. 按照任务分解进行开发
   ↓
3. 完成一组任务后，进入测试环节
   ↓
4. 查看测试方案文档（本文档）
   ↓
5. 编写自动化测试用例 + 编写测试数据
   ↓
6. 执行测试用例
   ↓
7. 测试通过 → 开始下一组任务开发
   测试未通过 → 根据测试结果修改代码 → 重新测试 → 直至通过
   ↓
8. 用户随机审查
   ↓
9. 如果发现测试通过但实际出错 → 更新测试用例模板
   ↓
10. 记录问题与经验到任务分解文档的错误总结
   ↓
11. 更新任务分解文档（标记完成状态）
```

### 1.2 测试方案（三部分）

**测试方案分为三个部分**：

---

## 第一部分：编写测试数据

### 1.2.1 核心任务

**清除UI交互代码中的假数据和伪代码，恢复成生产版本**

---

## 1.2.1.0 生产版本形态判定（必须先过 A/B，再进入 Playwright 用例阶段）

> 目标：避免“闷头清到 0 报错，但最终形态不是生产版本”的风险。

### A. 结构性判定（可脚本化、可量化，目标为 0）

**定义**：代码中不应再存在明确的 UI-DEV/伪代码标记与典型 mock 痕迹。

**强制指标（目标为 0）**：
- `UI_DEV_MARKERS`：`/* UI-DEV-START */` / `/* UI-DEV-END */`
- `IS_DEVMODE_CALL`：`isDevMode(...)`
- `DEVUTILS_IMPORT`：`@/utils/devUtils`
- `SET_TIMEOUT`：`setTimeout(...)`（业务流程伪延迟）
- `GENERATE_MOCK`：`generateMock*()`（本地生成假数据）
- `MOCK_IMAGES`：`/mock-images/`（假图片资源）
- `DEV_TOKEN`：`dev_token_` / `mock_token_` 等

**执行方式（只检查不写入）**：

```bash
cd shangnantea/shangnantea-web
npm run safe:ui-dev:prod-check:views
```

**产物**：
- 报告：`tests/test-data-templates/ui-dev-prod-check-report.md`
- 运行日志：`tests/test-data-templates/ui-dev-clean-runlog.md`

### B. 数据流判定（人工清单口径，必须满足）

**定义**：生产版本的数据流必须符合：

```
组件 → Composables/Vuex Actions → API → 后端
```

**必须满足的口径**：
- 组件层不再 `ref([...mock])` 造业务数据（列表/详情数据必须来自 Vuex state/computed）
- 组件层不再“本地伪成功”（不直接改数组/状态模拟删除/收藏/退款/发帖成功等）
- 所有业务动作必须 `dispatch('模块/action')`，由 action 调 API
- 暂无后端接口的功能：**保留入口**，但只允许提示“待后端接入”，不得伪造成功与本地状态

**记录方式**：
- 在对应模块的任务分解文档 “检查测试/错误总结” 中记录该页面是否已满足以上口径
- 同类问题多时，把人工改法抽象为脚本规则或 TODO 类型，减少后续成本

#### 1.2.1.1 前端代码恢复

**目标**：将前端代码恢复成正常的生产版本

**涉及范围**：
- **UI代码**：清除所有假数据和伪代码
- **状态管理（Vuex）**：使用生产版本的Vuex代码
- **API调用**：使用生产版本的API调用代码

**要求**：
- 完全对标连接后端从后端获取数据的方式
- 去掉所有为了测试而进行的折中方式
- 恢复成前端该有的样子
- UI代码 → 状态管理 → 接口调用都按照正常的生产版本

#### 1.2.1.2 后端代码修改

**目标**：修改后端接收前端请求的代码，直接返回测试数据

**实现方式**：
1. 前端与后端正常连接，向后端发送请求
2. **后端不调用业务逻辑和数据库**
3. 后端直接返回前端需要的数据（基于前端应有的响应格式）
4. 最大程度上模拟测试前端功能是否正常

**测试数据位置**：后端Controller层直接返回测试数据

#### 1.2.1.3 工作量评估

- **大头**：清除修改之前UI代码为正式的生产版本
- **中等**：状态管理和API调用代码改为生产版本
- **小头**：编写后端测试数据（直接返回数据，不调用业务逻辑）

---

## 第二部分：编写测试用例（真正的测试部分）

### 1.2.2 核心任务

**使用测试用例进行测试，发现问题 → 解决问题 → 通过测试**

#### 1.2.2.1 测试用例编写

- 使用测试用例模板编写
- 位置：`tests/[测试用例文件夹]/[模块名]/[功能名].spec.js`

#### 1.2.2.2 测试执行流程

```
1. 编写测试用例
   ↓
2. 执行测试用例
   ↓
3. 发现问题 → 分析问题 → 修改代码
   ↓
4. 重新执行测试
   ↓
5. 重复步骤3-4，直至测试通过
   ↓
6. 记录问题到任务分解文档的错误总结部分
```

#### 1.2.2.3 目录结构

```
tests/                          # 测试文件夹
├── [测试用例文件夹]/          # 测试用例（待创建）
│   └── [模块名]/
│       └── [功能名].spec.js
├── [测试用例模板文件夹]/      # 测试用例的规范与模板（待编写）
│   └── [模板文件]
└── [测试数据模板文件夹]/      # 测试数据模板（只有一个文档）
    └── README.md              # 记录清除修改伪代码的经验和写后端测试数据的经验
```

---

## 第三部分：更新测试用例模板或测试方案（可选项）

### 1.2.3 核心任务

**如果测试方法或测试用例出问题，需要改进方法和用例**

#### 1.2.3.1 触发条件

- 测试方法出现问题
- 测试用例出现问题
- 用户审查发现测试通过但实际出错

#### 1.2.3.2 更新内容

1. **更新测试用例模板**：改进测试用例的编写规范
2. **更新测试数据模板**：改进测试数据的编写经验
3. **更新测试方案文档**：改进测试流程和方法

#### 1.2.3.3 更新流程

```
1. 发现问题（测试方法或测试用例有问题）
   ↓
2. 分析问题原因
   ↓
3. 改进测试方法或测试用例
   ↓
4. 更新模板文档
   ↓
5. 更新测试方案文档（本文档）
```

### 1.3 测试工具

| 工具 | 用途 | 必须/可选 | 成本 |
|-----|------|---------|------|
| **Playwright** | 自动化测试框架 | 必须 | 免费 |
| **测试用例模板** | 编写测试用例的模板 | 必须 | 免费 |
| **测试数据模板** | 编写测试数据的模板 | 必须 | 免费 |
| **浏览器开发者工具** | 查看控制台、网络请求、DOM | 必须 | 免费 |
| **Vue DevTools** | 查看组件状态、Vuex状态变化 | 必须 | 免费 |

### 1.3 测试环境

```bash
# 1. 启动开发服务器
cd shangnantea/shangnantea-web
npm run serve

# 2. 访问地址（端口以控制台显示为准）
http://localhost:8082
```

---

## 二、测试执行标准流程（三部分）

### 2.1 第一部分：编写测试数据

#### 2.1.1 前端代码恢复（生产版本）

**步骤1: 清除UI代码中的假数据和伪代码**

```
1. 检查UI组件中的假数据（硬编码的数据、Mock数据）
2. 清除所有假数据和伪代码
3. 确保UI组件只负责展示，数据从Vuex获取
```

**步骤2: 恢复状态管理为生产版本**

```
1. 检查Vuex模块中的Mock数据逻辑
2. 移除所有Mock数据回退逻辑
3. 确保Vuex Actions正常调用API接口
4. 确保Vuex Mutations正常更新状态
```

**步骤3: 恢复API调用为生产版本**

```
1. 检查API文件中的Mock逻辑
2. 移除所有Mock数据逻辑
3. 确保API正常向后端发送请求
4. 确保API正常处理后端响应
```

**步骤4: 验证前端代码恢复完成**

```
1. 检查代码中无假数据和伪代码
2. 检查数据流向：UI → Vuex → API → 后端
3. 确保代码符合生产版本要求
```

#### 2.1.2 后端代码修改（返回测试数据）

**步骤1: 定位后端Controller**

```
1. 找到对应模块的Controller文件
2. 找到接收前端请求的方法
```

**步骤2: 修改Controller方法**

```
1. 接收前端请求（参数正常接收）
2. 不调用Service层业务逻辑
3. 不操作数据库
4. 直接返回测试数据（基于前端应有的响应格式）
```

**示例**：
```java
@GetMapping("/user/addresses")
public Result<List<AddressVO>> getAddresses() {
    // 不调用service.getAddresses()
    // 直接返回测试数据
    List<AddressVO> testData = createTestAddressData();
    return Result.success(testData);
}
```

**步骤3: 编写测试数据**

```
1. 根据前端API接口的响应格式编写测试数据
2. 确保测试数据覆盖各种场景（正常、边界、异常）
3. 确保测试数据独立，不影响其他测试
```

**步骤4: 验证后端测试数据**

```
1. 启动后端服务器
2. 使用Postman或浏览器测试API接口
3. 验证返回的测试数据格式正确
```

---

### 2.2 第二部分：编写测试用例（真正的测试部分）

#### 2.2.1 测试前准备

```
□ 1. 确认前端开发服务器已启动：npm run serve
□ 2. 确认后端服务器已启动：mvn spring-boot:run
□ 3. 确认前后端正常连接
□ 4. 确认测试用例模板可用：tests/[测试用例模板文件夹]/
```

#### 2.2.2 编写测试用例

**步骤1: 查看任务分解文档**

```
1. 查看任务分解文档，了解需要测试的功能
2. 确定测试范围和测试点
```

**步骤2: 选择测试用例模板**

```
1. 查看测试用例模板文件夹
2. 选择合适的模板（basic/form/list等）
3. 复制模板到：tests/[测试用例文件夹]/[模块名]/[功能名].spec.js
```

**步骤3: 编写测试用例**

```
1. 替换模板中的占位符
2. 编写具体测试步骤
3. 确保测试用例覆盖所有功能点
4. 确保测试用例独立，可重复执行
```

**参考文档**：
- 测试用例模板：`tests/[测试用例模板文件夹]/`
- 测试数据模板经验：`tests/[测试数据模板文件夹]/README.md`

#### 2.2.3 执行测试用例

**步骤1: 启动服务器**

```
1. 启动前端开发服务器：npm run serve
2. 启动后端服务器：mvn spring-boot:run
3. 确认前后端正常连接
```

**步骤2: 执行测试**

```
1. 执行测试用例（使用测试框架，如Playwright）
2. 观察测试执行过程
3. 查看测试结果
```

**步骤3: 处理测试结果**

**情况A：测试通过** ✅
```
1. 查看测试报告，确认所有断言通过
2. 记录测试结果到任务分解文档
3. 记录测试用例和测试数据位置到任务分解文档
4. 开始下一组任务开发
```

**情况B：测试未通过** ❌
```
1. 查看测试报告中的错误信息
2. 分析失败原因
3. 根据测试结果修改代码（前端或后端）
4. 重新执行测试
5. 重复步骤1-4，直至测试通过
6. 记录问题和解决方案到任务分解文档的错误总结部分
```

#### 2.2.4 记录测试结果

**在任务分解文档的"三、检查测试"部分记录**：

```
1. 更新测试用例的实际结果
2. 标记测试状态（通过/失败）
3. 记录测试日期
4. 记录测试用例位置：tests/[测试用例文件夹]/[模块名]/[功能名].spec.js
5. 记录测试数据位置：后端Controller中的测试数据
```

**在任务分解文档的"四、错误总结"部分记录**：

```
1. 记录开发中踩过的坑（4.3 经验教训）
2. 记录测试失败修改遇到的问题（4.1 已解决问题 或 4.2 待解决问题）
3. 记录解决方案和经验教训
```

---

### 2.3 第三部分：更新测试用例模板或测试方案（可选项）

#### 2.3.1 触发条件

- 测试方法出现问题
- 测试用例出现问题
- 用户审查发现测试通过但实际出错

#### 2.3.2 更新流程

**步骤1: 发现问题**

```
1. 识别问题（测试方法或测试用例有问题）
2. 分析问题原因
```

**步骤2: 改进方案**

```
1. 改进测试方法
2. 改进测试用例
3. 改进测试数据编写方式
```

**步骤3: 更新模板和文档**

```
1. 更新测试用例模板（tests/[测试用例模板文件夹]/）
2. 更新测试数据模板文档（tests/[测试数据模板文件夹]/README.md）
3. 更新测试方案文档（本文档）
```

**步骤4: 记录经验**

```
1. 在任务分解文档的错误总结部分记录改进经验
2. 确保后续测试用例遵循改进后的方案
```

### 2.3 测试结果判断标准

**测试通过标准**：
- ✅ 所有断言通过
- ✅ 无控制台Error级别错误
- ✅ UI显示正确
- ✅ 功能行为符合预期
- ✅ Vuex状态正确更新

**测试失败处理**：
- ❌ 查看测试报告：`tests/e2e/test-results/html-report/index.html`
- ❌ 查看截图：`tests/e2e/test-results/screenshots/`
- ❌ 查看视频：`tests/e2e/test-results/videos/`
- ❌ 分析错误信息，修改代码
- ❌ 重新执行测试

### 2.4 验收标准

**通过标准**：
- ✅ UI显示正确，无异常
- ✅ 控制台无报错（警告可接受）
- ✅ Vuex状态正确更新
- ✅ 功能行为符合预期

**失败标准**：
- ❌ UI显示异常或空白
- ❌ 控制台有Error级别错误
- ❌ Vuex状态未更新或更新错误
- ❌ 功能行为不符合预期

---

## 三、测试用例模板与测试数据模板

### 3.1 目录结构

```
tests/                              # 测试文件夹
├── [测试用例文件夹]/              # 测试用例（待创建）
│   └── [模块名]/
│       └── [功能名].spec.js
├── [测试用例模板文件夹]/          # 测试用例的规范与模板（待编写）
│   └── [模板文件]
└── [测试数据模板文件夹]/          # 测试数据模板（只有一个文档）
    └── README.md                  # 记录清除修改伪代码的经验和写后端测试数据的经验
```

### 3.2 模板使用原则

**重要**：所有测试用例和测试数据**必须依照模板编写**

#### 3.2.1 测试用例模板

**位置**：`tests/[测试用例模板文件夹]/`（待编写）

**模板类型**（待创建）：
- 基础测试模板（通用功能）
- 表单测试模板（表单提交、数据录入）
- 列表测试模板（列表展示、分页、筛选）

**使用步骤**：
1. 查看测试用例模板文件夹
2. 选择合适的模板
3. 复制模板到：`tests/[测试用例文件夹]/[模块名]/[功能名].spec.js`
4. 替换所有 `[占位符]` 为实际值
5. 根据实际功能编写测试步骤
6. 确保测试用例覆盖所有功能点

#### 3.2.2 测试数据模板

**位置**：`tests/[测试数据模板文件夹]/README.md`（待创建）

**内容**：
- 清除修改伪代码的经验
- 写后端测试数据的经验
- 方便后续测试数据的编写

**使用步骤**：
1. 查看测试数据模板文档
2. 参考文档中的经验编写后端测试数据
3. 在后端Controller中直接返回测试数据
4. 确保测试数据基于前端应有的响应格式

### 3.3 模板更新机制（第三部分）

#### 3.3.1 何时更新模板

**触发条件**：
- 测试方法出现问题
- 测试用例出现问题
- 用户审查发现测试通过但实际出错

**更新流程**：
1. 分析为什么测试没有发现问题
2. 改进测试方法或测试用例
3. **更新测试用例模板**（`tests/[测试用例模板文件夹]/`）
4. **更新测试数据模板文档**（`tests/[测试数据模板文件夹]/README.md`）
5. **更新测试方案文档**（本文档）
6. 在任务分解文档的错误总结部分记录改进经验

#### 3.3.2 模板更新原则

- **向后兼容**：新模板应兼容已有测试用例
- **文档同步**：更新模板时同步更新相关文档
- **经验积累**：将改进经验记录到测试数据模板文档中
- **版本记录**：在模板文件中记录更新历史

### 3.4 模板内容要求（待编写时确定）

#### 3.4.1 测试用例模板必须包含（待编写时确定）

待编写测试用例模板时确定具体内容要求。

#### 3.4.2 测试数据模板文档必须包含

1. **清除修改伪代码的经验**
   - 如何清除UI代码中的假数据
   - 如何恢复状态管理为生产版本
   - 如何恢复API调用为生产版本
   - 常见问题和解决方案

2. **写后端测试数据的经验**
   - 如何修改后端Controller返回测试数据
   - 如何编写符合前端响应格式的测试数据
   - 如何覆盖各种测试场景
   - 常见问题和解决方案

---

## 四、测试结果记录与任务分解文档更新

### 4.1 记录位置

**重要**：所有测试及开发过程中遇到的问题和经验，必须记录到**任务分解文档的错误总结**部分

**任务分解文档位置**：`docs/tasks/0X-[模块名]-module-tasks.md`

**记录部分**：
- **4.1 已解决问题**：记录已解决的问题和解决方案
- **4.2 待解决问题**：记录待解决的问题
- **4.3 经验教训**：记录经验教训和改进建议

### 4.2 问题记录格式（记录到任务分解文档）

```markdown
### 4.1 已解决问题

| 日期 | 问题描述 | 解决方案 | 相关任务 |
|------|----------|----------|----------|
| 2024-12-17 | [问题描述] | [解决方案] | [任务组编号] |

### 4.2 待解决问题

| 日期 | 问题描述 | 优先级 | 状态 |
|------|----------|--------|------|
| 2024-12-17 | [问题描述] | 高/中/低 | 待解决 |

### 4.3 经验教训

| 日期 | 教训描述 | 影响范围 |
|------|----------|----------|
| 2024-12-17 | [教训描述] | [影响范围] |
```

### 4.3 测试结果记录（记录到任务分解文档）

在任务分解文档的"三、检查测试"部分，更新测试用例的实际结果：

```markdown
#### 测试用例A-T1：获取地址列表

**实际结果**：
- ✅ 页面正常加载
- ✅ 地址列表显示正确
- ⚠️ 控制台有1个Error（但不影响功能）

**状态**：✅ 通过（功能正常，但有需要修复的错误）
**测试日期**：2024-12-17

**测试用例位置**：tests/[测试用例文件夹]/user/address.spec.js
**测试数据位置**：后端Controller - UserController.getAddresses()方法
```

### 4.4 任务分解文档更新（完成一组任务后）

**必须更新的内容**：

1. **任务完成状态**
   - 在"二、具体实施"部分，标记任务为已完成
   - 更新"五、进度追踪"部分的完成度

2. **测试结果**
   - 在"三、检查测试"部分，更新测试用例的实际结果
   - 记录测试日期和状态

3. **错误总结**
   - 在"四、错误总结"部分，记录遇到的问题和经验教训

4. **里程碑**
   - 更新"五、进度追踪"部分的里程碑状态

### 4.5 记录内容要求

#### 必须记录的内容

1. **问题描述**：清晰描述遇到的问题
2. **解决方案**：详细说明如何解决的
3. **经验教训**：总结可以避免类似问题的经验
4. **影响范围**：说明影响哪些模块或功能

#### 记录时机

- **测试过程中**：发现问题立即记录
- **测试完成后**：总结测试结果和经验
- **用户审查后**：如果发现测试通过但实际出错，记录并更新模板

---

## 五、快速测试脚本

### 5.1 获取Store实例

```javascript
// 方法1：通过Vue DevTools
const store = window.__VUE_DEVTOOLS_GLOBAL_HOOK__?.Vue?.app?.config?.globalProperties?.$store

// 方法2：通过DOM
const store = document.querySelector('#app').__vue_app__.config.globalProperties.$store

// 验证store是否获取成功
if (store) {
  console.log('✅ Store获取成功')
  console.log('当前state:', store.state)
} else {
  console.log('❌ Store获取失败')
}
```

### 5.2 通用测试辅助函数

```javascript
// 复制到控制台使用
const TestHelper = {
  // 获取store
  getStore() {
    return window.__VUE_DEVTOOLS_GLOBAL_HOOK__?.Vue?.app?.config?.globalProperties?.$store
      || document.querySelector('#app')?.__vue_app__?.config?.globalProperties?.$store
  },
  
  // 检查状态
  checkState(moduleName, propertyName) {
    const store = this.getStore()
    if (!store) return console.log('❌ Store获取失败')
    const value = store.state[moduleName]?.[propertyName]
    console.log(`${moduleName}.${propertyName}:`, value)
    return value
  },
  
  // 执行action并打印结果
  async testAction(actionName, payload) {
    const store = this.getStore()
    if (!store) return console.log('❌ Store获取失败')
    console.log(`执行 ${actionName}，参数:`, payload)
    try {
      const result = await store.dispatch(actionName, payload)
      console.log('✅ 执行成功，返回:', result)
      return result
    } catch (error) {
      console.log('❌ 执行失败:', error)
      throw error
    }
  },
  
  // 检查getter
  checkGetter(getterName) {
    const store = this.getStore()
    if (!store) return console.log('❌ Store获取失败')
    const value = store.getters[getterName]
    console.log(`getter[${getterName}]:`, value)
    return value
  }
}

// 使用示例
// TestHelper.checkState('user', 'addressList')
// TestHelper.testAction('user/fetchAddresses')
// TestHelper.checkGetter('user/defaultAddress')
```

---

## 六、各模块测试入口

| 模块 | 测试页面路径 | 需要登录 |
|-----|-------------|---------|
| 用户-地址管理 | `/user/address` | 是 |
| 用户-收藏 | `/message/favorites` | 是 |
| 用户-关注 | `/message/follows` | 是 |
| 茶叶-列表 | `/tea/list` | 否 |
| 茶叶-详情 | `/tea/detail/:id` | 否 |
| 店铺-列表 | `/shop/list` | 否 |
| 店铺-详情 | `/shop/detail/:id` | 否 |
| 订单-列表 | `/order/list` | 是 |
| 购物车 | `/order/cart` | 是 |
| 论坛-列表 | `/forum/list` | 否 |
| 消息-通知 | `/message/notifications` | 是 |
| 消息-聊天 | `/message/chat` | 是 |

---

## 七、测试完成标准

### 7.1 单个任务完成标准

- [ ] 所有功能测试用例执行完毕
- [ ] 所有用例状态已标记（通过/失败）
- [ ] 失败用例已记录详细问题信息
- [ ] 控制台无Error级别错误

### 7.2 任务组完成标准

- [ ] 所有任务的测试已完成
- [ ] 测试报告已填写
- [ ] 所有高优先级Bug已修复
- [ ] 修复后的Bug已重新验证
- [ ] 任务组状态更新为"已完成"

### 7.3 模块完成标准

- [ ] 所有任务组测试已完成
- [ ] 集成测试已执行
- [ ] 无未解决的高优先级Bug
- [ ] 测试覆盖率达到预期（所有功能点都有对应测试）

---

**文档版本**: 1.0  
**创建日期**: 2024-12-17  
**适用范围**: 所有模块的任务分解

---

## 七、测试方案总结（三部分）

### 7.1 测试方案三部分概述

**测试方案分为三个部分**：

#### 第一部分：编写测试数据

**核心任务**：
1. **清除UI交互代码中的假数据和伪代码**
   - UI代码恢复成生产版本
   - 状态管理（Vuex）恢复成生产版本
   - API调用恢复成生产版本
   - 完全对标连接后端从后端获取数据的方式

2. **修改后端代码返回测试数据**
   - 后端接收前端请求
   - 不调用业务逻辑和数据库
   - 直接返回测试数据（基于前端应有的响应格式）

**工作量**：
- 大头：清除修改之前UI代码为正式的生产版本
- 中等：状态管理和API调用代码改为生产版本
- 小头：编写后端测试数据

#### 第二部分：编写测试用例（真正的测试部分）

**核心任务**：
1. **编写测试用例**（使用测试用例模板）
2. **执行测试用例**
3. **发现问题 → 解决问题 → 通过测试**
4. **记录问题到任务分解文档的错误总结部分**

**目录结构**：
```
tests/
├── [测试用例文件夹]/          # 测试用例
├── [测试用例模板文件夹]/      # 测试用例的规范与模板（待编写）
└── [测试数据模板文件夹]/      # 测试数据模板（只有一个文档）
    └── README.md              # 清除修改伪代码的经验和写后端测试数据的经验
```

#### 第三部分：更新测试用例模板或测试方案（可选项）

**核心任务**：
- 如果测试方法或测试用例出问题，需要改进方法和用例
- 更新测试用例模板
- 更新测试数据模板文档
- 更新测试方案文档

### 7.2 开发与测试流程

```
开发阶段（以任务分解文档为纲领）
   ↓
完成一组任务
   ↓
测试阶段（查看测试方案文档 - 本文档）
   ↓
第一部分：编写测试数据
  - 清除UI代码中的假数据和伪代码
  - 恢复前端代码为生产版本
  - 修改后端代码返回测试数据
   ↓
第二部分：编写测试用例
  - 编写测试用例（依照测试用例模板）
  - 执行测试用例
  - 发现问题 → 解决问题 → 通过测试
  - 记录问题到任务分解文档的错误总结
   ↓
测试通过 → 开始下一组任务开发
测试未通过 → 根据测试结果修改代码 → 重新测试 → 直至通过
   ↓
用户随机审查
   ↓
第三部分：更新测试用例模板或测试方案（可选项）
  - 如果发现测试通过但实际出错
  - 更新测试用例模板
  - 更新测试数据模板文档
  - 更新测试方案文档
   ↓
更新任务分解文档
  - 测试部分：更新测试结果 + 记录测试用例/数据位置
  - 总结部分：记录问题和经验
  - 进度追踪：标记任务完成状态
```

### 7.3 模板使用

**测试用例模板**：
- 位置：`tests/[测试用例模板文件夹]/`（待编写）
- 必须依照模板编写
- 模板更新：第三部分（可选项）

**测试数据模板**：
- 位置：`tests/[测试数据模板文件夹]/README.md`（待创建）
- 内容：清除修改伪代码的经验和写后端测试数据的经验
- 模板更新：第三部分（可选项）

### 7.4 文档更新要求

**任务分解文档更新**（完成一组任务后必须更新）：

1. **测试部分（三、检查测试）**：
   - 更新测试用例的实际结果
   - 标记测试状态（通过/失败）
   - 记录测试日期
   - **记录测试用例位置**：`tests/[测试用例文件夹]/[模块名]/[功能名].spec.js`
   - **记录测试数据位置**：后端Controller中的测试数据

2. **总结部分（四、错误总结）**：
   - **4.1 已解决问题**：记录测试失败修改遇到的问题和解决方案
   - **4.2 待解决问题**：记录待解决的问题
   - **4.3 经验教训**：记录开发中踩过的坑和测试经验

3. **进度追踪（五、进度追踪）**：
   - 标记任务完成状态
   - 更新完成度
   - 更新里程碑状态

---

**文档版本**: 3.0  
**创建日期**: 2024-12-17  
**最后更新**: 2024-12-17  
**适用范围**: 所有模块的任务分解

