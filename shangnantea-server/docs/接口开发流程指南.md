# 接口开发流程指南

> 基于登录和注册功能的完整开发流程，用于指导后续165个接口的开发

## 目录

1. [整体架构与数据流向](#整体架构与数据流向)
2. [各层职责说明](#各层职责说明)
3. [标准开发流程](#标准开发流程)
4. [代码示例](#代码示例)
5. [注意事项与最佳实践](#注意事项与最佳实践)
6. [开发检查清单](#开发检查清单)

---

## 整体架构与数据流向

### 架构图

```
前端 (Vue) 
    ↓ HTTP请求
Controller层 (接收请求，参数验证)
    ↓ 调用Service方法
Service层 (业务逻辑处理)
    ↓ 调用Mapper方法
Mapper层 (数据访问)
    ↓ SQL执行
数据库 (MySQL)
    ↓ 返回数据
Mapper层 (返回Entity)
    ↓ 转换为VO
Service层 (返回Result<T>)
    ↓ 返回Result
Controller层 (直接返回)
    ↓ HTTP响应
前端 (Vue) (处理响应)
```

### 数据流向说明

1. **前端发起请求** → 调用 `src/api/` 中的API函数
2. **API层** → 通过axios发送HTTP请求到后端
3. **Controller层** → 接收请求，进行参数验证（`@Valid`），直接调用Service方法
4. **Service层** → 处理业务逻辑，调用Mapper进行数据库操作，返回 `Result<T>`
5. **Mapper层** → 执行SQL，返回Entity对象
6. **Service层** → 将Entity转换为VO，包装为 `Result<T>` 返回
7. **Controller层** → 直接返回Service的 `Result<T>`
8. **前端** → 接收响应，根据 `code` 判断成功/失败，处理 `data`

---

## 各层职责说明

### 1. Controller层 (`controller/`)

**职责：**
- 接收HTTP请求
- 参数验证（使用 `@Valid` 和DTO类）
- 调用Service层方法
- 直接返回Service的 `Result<T>`，不做任何业务处理

**禁止：**
- ❌ 在Controller中编写业务逻辑
- ❌ 在Controller中处理异常（由GlobalExceptionHandler统一处理）
- ❌ 在Controller中转换数据格式
- ❌ 在Controller中返回 `message` 字段（只返回 `code` 和 `data`）

**示例：**
```java
@PostMapping("/login")
public Result<TokenVO> login(@RequestBody @Valid LoginDTO loginDTO) {
    logger.info("用户登录请求: {}", loginDTO.getUsername());
    return userService.login(loginDTO); // 直接返回，不做处理
}
```

### 2. Service层 (`service/` 和 `service/impl/`)

**职责：**
- 实现所有业务逻辑
- 调用Mapper进行数据库操作
- 数据转换（Entity → VO）
- 返回 `Result<T>` 对象
- 处理业务异常，返回对应的错误码

**必须：**
- ✅ 所有业务逻辑都在Service层实现
- ✅ 返回 `Result<T>` 类型
- ✅ 使用 `Result.success(code, data)` 返回成功
- ✅ 使用 `Result.failure(code)` 返回失败（不包含message）
- ✅ 记录日志（info/warn/error）

**示例：**
```java
@Override
public Result<TokenVO> login(LoginDTO loginDTO) {
    logger.info("用户登录请求: {}", loginDTO.getUsername());
    
    // 业务逻辑：验证用户名密码
    User user = checkUserAndPassword(loginDTO.getUsername(), loginDTO.getPassword());
    if (user == null) {
        logger.warn("登录失败: 用户名或密码错误");
        return Result.failure(2100); // 返回错误码，不包含message
    }
    
    // 业务逻辑：生成token
    String token = jwtUtil.generateToken(user);
    TokenVO tokenVO = new TokenVO();
    tokenVO.setToken(token);
    tokenVO.setUserInfo(convertToUserVO(user));
    
    logger.info("登录成功: username: {}", loginDTO.getUsername());
    return Result.success(2000, tokenVO); // 返回成功码和数据
}
```

### 3. Mapper层 (`mapper/` 和 `resources/mapper/`)

**职责：**
- 定义数据库操作方法
- 执行SQL查询
- 返回Entity对象

**注意：**
- Mapper接口定义在 `mapper/` 包中
- SQL映射文件在 `resources/mapper/` 目录中
- 通常不需要修改，除非需要新增数据库操作

**示例：**
```java
// UserMapper.java
User selectByUsername(String username);
User selectById(String id);
int insert(User user);
int update(User user);
```

### 4. 数据模型层

#### DTO (Data Transfer Object) - `model/dto/`
- 用于接收前端请求参数
- 包含参数验证注解（`@NotNull`, `@NotBlank`, `@Size` 等）

#### Entity - `model/entity/`
- 对应数据库表结构
- 用于Mapper层返回数据

#### VO (Value Object) - `model/vo/`
- 用于返回给前端的数据
- 不包含敏感信息（如密码）
- 可能包含计算字段

**转换关系：**
```
前端请求 → DTO → Service处理 → Entity (数据库) → VO → 前端响应
```

### 5. 前端API层 (`src/api/`)

**职责：**
- 定义API函数
- 调用axios发送请求
- 返回Promise

**示例：**
```javascript
export function login(loginData) {
  return request({
    url: API.USER.LOGIN,
    method: 'post',
    data: loginData
  })
}
```

---

## 标准开发流程

### 步骤1：确定接口需求

1. **查看接口文档（主要依据）：**
   - 查看 `openapi_new.yaml` 中的接口定义
   - 这是接口开发的主要依据，必须严格按照接口文档实现

2. **理解业务背景（参考）：**
   - 可选：阅读 `development-guide.md` 中相关模块的功能说明
   - 用于理解业务逻辑和功能背景
   - **注意：** 如果文档描述与接口定义不一致，以接口定义为准

3. **确定开发要素：**
   - HTTP方法和路径（来自接口文档）
   - 请求参数（创建DTO类，参考接口文档的requestBody）
   - 响应数据（创建VO类，参考接口文档的responses）
   - 成功码和失败码（参考 `code-message-mapping.md`）

### 步骤2：创建/修改DTO类

**位置：** `src/main/java/com/shangnantea/model/dto/`

**要求：**
- 类名以 `DTO` 结尾
- 包含参数验证注解
- 实现 `Serializable` 接口（可选）

**示例：**
```java
package com.shangnantea.model.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class LoginDTO implements Serializable {
    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 20, message = "用户名长度必须在3-20之间")
    private String username;
    
    @NotBlank(message = "密码不能为空")
    @Size(min = 6, max = 20, message = "密码长度必须在6-20之间")
    private String password;
    
    // getter和setter
}
```

### 步骤3：创建/修改VO类

**位置：** `src/main/java/com/shangnantea/model/vo/`

**要求：**
- 类名以 `VO` 结尾
- 不包含敏感信息
- 实现 `Serializable` 接口（可选）

**示例：**
```java
package com.shangnantea.model.vo.user;

public class TokenVO implements Serializable {
    private String token;
    private UserVO userInfo;
    
    // getter和setter
}
```

### 步骤4：在Service接口中定义方法

**位置：** `src/main/java/com/shangnantea/service/`

**要求：**
- 方法返回类型为 `Result<T>`
- 参数使用DTO类型
- 添加JavaDoc注释

**示例：**
```java
/**
 * 用户登录
 *
 * @param loginDTO 登录信息
 * @return 登录结果，包含token和用户信息
 */
Result<TokenVO> login(LoginDTO loginDTO);
```

### 步骤5：实现Service方法

**位置：** `src/main/java/com/shangnantea/service/impl/`

**步骤：**
1. 参数验证（如果DTO验证不够）
2. 业务逻辑处理
3. 调用Mapper进行数据库操作
4. 数据转换（Entity → VO）
5. 返回 `Result<T>`

**关键点：**
- 使用 `Result.success(code, data)` 返回成功
- 使用 `Result.failure(code)` 返回失败
- 记录日志
- 事务管理（需要时使用 `@Transactional`）
- 用户身份验证（需要时使用 `UserContext.getCurrentUserId()`）

**示例：**
```java
@Override
public Result<TokenVO> login(LoginDTO loginDTO) {
    logger.info("用户登录请求: {}", loginDTO.getUsername());
    
    // 1. 业务逻辑：验证用户
    User user = checkUserAndPassword(loginDTO.getUsername(), loginDTO.getPassword());
    if (user == null) {
        logger.warn("登录失败: 用户名或密码错误");
        return Result.failure(2100);
    }
    
    // 2. 业务逻辑：检查状态
    if (user.getStatus() == 0) {
        logger.warn("登录失败: 用户已被禁用");
        return Result.failure(2100);
    }
    
    // 3. 业务逻辑：生成token
    String token = jwtUtil.generateToken(user);
    if (token == null) {
        logger.error("登录失败: Token生成失败");
        return Result.failure(2105);
    }
    
    // 4. 数据转换：Entity → VO
    TokenVO tokenVO = new TokenVO();
    tokenVO.setToken(token);
    tokenVO.setUserInfo(convertToUserVO(user));
    
    logger.info("登录成功: username: {}", loginDTO.getUsername());
    return Result.success(2000, tokenVO);
}
```

### 步骤6：在Controller中添加接口

**位置：** `src/main/java/com/shangnantea/controller/`

**要求：**
- 使用 `@PostMapping`, `@GetMapping`, `@PutMapping`, `@DeleteMapping` 等注解
- 参数使用 `@RequestBody @Valid DTO` 或 `@PathVariable`, `@RequestParam`
- 直接返回Service的 `Result<T>`
- 添加JavaDoc注释，包含路径和成功码/失败码

**示例：**
```java
/**
 * 用户登录
 * 路径: POST /user/login
 * 成功码: 2000, 失败码: 2100, 2105
 *
 * @param loginDTO 登录信息
 * @return 登录结果
 */
@PostMapping("/login")
public Result<TokenVO> login(@RequestBody @Valid LoginDTO loginDTO) {
    logger.info("用户登录请求: {}", loginDTO.getUsername());
    return userService.login(loginDTO);
}
```

### 步骤7：前端API函数（如需要）

**位置：** `shangnantea-web/src/api/`

**要求：**
- 在对应的模块文件中添加函数（如 `user.js`, `tea.js` 等）
- 使用 `request` 方法发送请求
- 添加JSDoc注释

**示例：**
```javascript
/**
 * 用户登录
 * @param {Object} loginData 登录数据 {username, password}
 * @returns {Promise} 登录结果
 */
export function login(loginData) {
  return request({
    url: API.USER.LOGIN,
    method: 'post',
    data: loginData
  })
}
```

### 步骤8：测试

1. **后端测试：**
   - 启动后端服务器
   - 使用Postman或Apifox测试接口
   - 验证返回的 `code` 和 `data` 格式

2. **前端测试：**
   - 启动前端服务器
   - 在浏览器中测试功能
   - 检查控制台日志

---

---

## 代码示例

### 完整示例：用户注册功能

#### 1. DTO类
```java
// RegisterDTO.java
package com.shangnantea.model.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public class RegisterDTO implements Serializable {
    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 20, message = "用户名长度必须在3-20之间")
    private String username;
    
    @NotBlank(message = "密码不能为空")
    @Size(min = 6, max = 20, message = "密码长度必须在6-20之间")
    private String password;
    
    @NotBlank(message = "确认密码不能为空")
    private String confirmPassword;
    
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    private String phone;
    
    @Email(message = "邮箱格式不正确")
    private String email;
    
    // getter和setter
}
```

#### 2. VO类
```java
// UserVO.java
package com.shangnantea.model.vo.user;

public class UserVO implements Serializable {
    private String id;
    private String username;
    private String phone;
    private String email;
    private Integer role;
    private Integer status;
    // 不包含password字段
    
    // getter和setter
}
```

#### 3. Service接口
```java
// UserService.java
Result<UserVO> register(RegisterDTO registerDTO);
```

#### 4. Service实现
```java
// UserServiceImpl.java
@Override
@Transactional(rollbackFor = Exception.class)
public Result<UserVO> register(RegisterDTO registerDTO) {
    logger.info("用户注册请求: {}", registerDTO.getUsername());
    
    // 1. 检查用户名是否已存在
    if (isUserExist(registerDTO.getUsername())) {
        logger.warn("注册失败: 用户名已存在");
        return Result.failure(2101);
    }
    
    // 2. 验证密码一致性
    if (!registerDTO.getPassword().equals(registerDTO.getConfirmPassword())) {
        logger.warn("注册失败: 两次输入的密码不一致");
        return Result.failure(2101);
    }
    
    // 3. 转换为Entity
    User user = new User();
    user.setUsername(registerDTO.getUsername());
    user.setPassword(registerDTO.getPassword());
    user.setPhone(registerDTO.getPhone());
    user.setEmail(registerDTO.getEmail());
    
    // 4. 设置默认值
    user.setId(generateUserId());
    user.setPassword(passwordEncoder.encode(user.getPassword()));
    user.setRole(2); // 普通用户
    user.setStatus(1); // 正常状态
    user.setIsDeleted(0);
    user.setCreateTime(new Date());
    user.setUpdateTime(new Date());
    
    // 5. 保存到数据库
    int result = userMapper.insert(user);
    if (result <= 0) {
        logger.error("注册失败: 数据库插入失败");
        return Result.failure(2101);
    }
    
    logger.info("用户注册成功: username: {}, userId: {}", 
                registerDTO.getUsername(), user.getId());
    return Result.success(2001, convertToUserVO(user));
}
```

#### 5. Controller
```java
// UserController.java
@PostMapping("/register")
public Result<UserVO> register(@RequestBody @Valid RegisterDTO registerDTO) {
    logger.info("用户注册请求: {}", registerDTO.getUsername());
    return userService.register(registerDTO);
}
```

#### 6. 前端API
```javascript
// user.js
export function register(registerData) {
  return request({
    url: API.USER.REGISTER,
    method: 'post',
    data: registerData
  })
}
```

---

## 注意事项与最佳实践

### 1. 错误码使用

- **参考文档：** `code-message-mapping.md`
- **使用方式：** `Result.failure(错误码)`，不包含message
- **前端处理：** 前端根据 `code` 映射到对应的错误消息

### 2. 日志记录

- **Info级别：** 记录正常业务流程（如：用户登录请求、操作成功）
- **Warn级别：** 记录业务异常（如：登录失败、参数错误）
- **Error级别：** 记录系统异常（如：数据库操作失败、Token生成失败）

### 3. 事务管理

- **使用场景：** 涉及多个数据库操作的方法
- **注解：** `@Transactional(rollbackFor = Exception.class)`
- **位置：** Service实现类的方法上

### 4. 参数验证

- **DTO验证：** 使用 `@Valid` 和验证注解（`@NotBlank`, `@Size` 等）
- **业务验证：** 在Service层进行（如：用户名是否存在、密码是否正确）

### 5. 数据转换

- **Entity → VO：** 在Service层进行转换
- **转换方法：** 创建私有方法 `convertToVO(Entity entity)`
- **敏感信息：** VO中不包含密码等敏感字段

### 6. 异常处理

- **业务异常：** 在Service层处理，返回 `Result.failure(code)`
- **系统异常：** 由 `GlobalExceptionHandler` 统一处理
- **Controller层：** 不处理异常，直接抛出

### 7. 数据类型匹配

- **实体类ID类型：** 确保实体类的ID类型与Mapper接口泛型参数一致
- **XML参数类型：** 确保XML文件中的parameterType与实际参数类型匹配
- **常见问题：** 实体使用String ID但Mapper定义为Long，会导致运行时错误

### 8. 代码规范

- **命名：** DTO以 `DTO` 结尾，VO以 `VO` 结尾
- **注释：** 所有公共方法必须有JavaDoc注释
- **格式：** 使用4个空格缩进，每行不超过120个字符

---

## 开发检查清单

在完成一个接口开发后，请检查以下项目：

### 后端检查

- [ ] DTO类已创建，包含参数验证注解（普通接口）
- [ ] VO类已创建，不包含敏感信息（普通接口）
- [ ] Service接口已定义方法，返回 `Result<T>`
- [ ] Service实现已完成，包含业务逻辑和错误处理
- [ ] Controller已添加接口，直接返回Service的 `Result<T>`
- [ ] 日志记录已添加（info/warn/error）
- [ ] 错误码已确认（参考 `code-message-mapping.md`）
- [ ] 事务管理已添加（如需要）
- [ ] 用户身份验证已添加（如需要）
- [ ] 代码已通过编译
- [ ] 接口已通过Postman/Apifox测试

### 前端检查（如需要）

- [ ] API函数已添加到对应的模块文件
- [ ] API常量已添加到 `apiConstants.js`
- [ ] 前端调用已测试

### 文档检查

- [ ] 接口路径和HTTP方法已确认
- [ ] 成功码和失败码已记录
- [ ] JavaDoc注释已添加

---

## 常见问题

### Q1: Controller中需要处理异常吗？

**A:** 不需要。异常由 `GlobalExceptionHandler` 统一处理，Controller直接返回Service的 `Result<T>`。

### Q2: Service方法必须返回 `Result<T>` 吗？

**A:** 是的。所有对外接口的Service方法必须返回 `Result<T>`，内部辅助方法可以返回其他类型。

### Q3: 如何确定错误码？

**A:** 参考 `code-message-mapping.md` 文档，根据业务场景选择合适的错误码。

### Q4: 什么时候需要事务管理？

**A:** 当方法涉及多个数据库操作，且需要保证原子性时，使用 `@Transactional`。

### Q5: Entity和VO的区别？

**A:** Entity对应数据库表结构，VO用于返回给前端，不包含敏感信息，可能包含计算字段。

### Q7: 实体类ID类型与Mapper不匹配怎么办？

**A:** 确保实体类的ID类型与Mapper接口的泛型参数一致。例如：如果ChatSession使用String ID，则ChatSessionMapper应为BaseMapper<ChatSession, String>，同时检查XML文件中的parameterType。

---

## 参考文件

### 核心参考文档

- **OpenAPI接口文档：** `openapi_new.yaml`（主要参考）
  - 这是接口开发的主要依据
  - 定义了所有接口的路径、方法、参数、响应格式
  - 必须严格按照接口文档实现功能

- **消息码映射：** `shangnantea-web/docs/tasks/code-message-mapping.md`
  - 定义了所有成功码和失败码
  - 用于确定接口返回的错误码

### 功能理解参考文档

- **前端开发指南：** `shangnantea-web/docs/development-guide.md`
  - **用途：** 用于理解项目整体功能和业务逻辑
  - **说明：** 
    - 该文档是对项目各个功能模块的大致说明
    - 主要用于加深对接口所需功能的理解
    - 帮助开发者理解业务背景，避免实现逻辑与预期偏差过大
  - **注意事项：**
    - ⚠️ 该文档是给前端开发做指导的，用语言描述的是最终产品形态
    - ⚠️ 某些功能描述可能超出了实际接口定义的范围
    - ⚠️ **接口开发应以 `openapi_new.yaml` 为准**，围绕接口文档实现接口的本职功能
    - ⚠️ 该文档仅作为理解参考，不能替代接口文档作为开发依据
  - **使用建议：**
    - 开发前先阅读相关模块的功能说明，理解业务背景
    - 然后对照 `openapi_new.yaml` 中的接口定义进行开发
    - 如果文档描述与接口定义不一致，以接口定义为准

### 代码示例参考

- **登录示例：** `UserController.login()`, `UserService.login()`
- **注册示例：** `UserController.register()`, `UserService.register()`

---

**文档版本：** v1.1  
**最后更新：** 2026-01-21  
**基于功能：** 用户登录、用户注册、用户头像上传（补充实际开发经验）

