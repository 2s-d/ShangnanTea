# 接口开发流程指南

> 基于登录和注册功能的完整开发流程，用于指导后续165个接口的开发

## 目录

1. [整体架构与数据流向](#整体架构与数据流向)
2. [各层职责说明](#各层职责说明)
3. [标准开发流程](#标准开发流程)
4. [代码示例](#代码示例)
5. [注意事项与最佳实践](#注意事项与最佳实践)
6. [开发检查清单](#开发检查清单)

---

## 整体架构与数据流向

### 架构图

```
前端 (Vue) 
    ↓ HTTP请求
Controller层 (接收请求，参数验证)
    ↓ 调用Service方法
Service层 (业务逻辑处理)
    ↓ 调用Mapper方法
Mapper层 (数据访问)
    ↓ SQL执行
数据库 (MySQL)
    ↓ 返回数据
Mapper层 (返回Entity)
    ↓ 转换为VO
Service层 (返回Result<T>)
    ↓ 返回Result
Controller层 (直接返回)
    ↓ HTTP响应
前端 (Vue) (处理响应)
```

### 数据流向说明

1. **前端发起请求** → 调用 `src/api/` 中的API函数
2. **API层** → 通过axios发送HTTP请求到后端
3. **Controller层** → 接收请求，进行参数验证（`@Valid`），直接调用Service方法
4. **Service层** → 处理业务逻辑，调用Mapper进行数据库操作，返回 `Result<T>`
5. **Mapper层** → 执行SQL，返回Entity对象
6. **Service层** → 将Entity转换为VO，包装为 `Result<T>` 返回
7. **Controller层** → 直接返回Service的 `Result<T>`
8. **前端** → 接收响应，根据 `code` 判断成功/失败，处理 `data`

---

## 各层职责说明

### 1. Controller层 (`controller/`)

**职责：**
- 接收HTTP请求
- 参数验证（使用 `@Valid` 和DTO类）
- 调用Service层方法
- 直接返回Service的 `Result<T>`，不做任何业务处理

**禁止：**
- ❌ 在Controller中编写业务逻辑
- ❌ 在Controller中处理异常（由GlobalExceptionHandler统一处理）
- ❌ 在Controller中转换数据格式
- ❌ 在Controller中返回 `message` 字段（只返回 `code` 和 `data`）

**示例：**
```java
@PostMapping("/login")
public Result<TokenVO> login(@RequestBody @Valid LoginDTO loginDTO) {
    logger.info("用户登录请求: {}", loginDTO.getUsername());
    return userService.login(loginDTO); // 直接返回，不做处理
}
```

### 2. Service层 (`service/` 和 `service/impl/`)

**职责：**
- 实现所有业务逻辑
- 调用Mapper进行数据库操作
- 数据转换（Entity → VO）
- 返回 `Result<T>` 对象
- 处理业务异常，返回对应的错误码

**必须：**
- ✅ 所有业务逻辑都在Service层实现
- ✅ 返回 `Result<T>` 类型
- ✅ 使用 `Result.success(code, data)` 返回成功
- ✅ 使用 `Result.failure(code)` 返回失败（不包含message）
- ✅ 记录日志（info/warn/error）

**示例：**
```java
@Override
public Result<TokenVO> login(LoginDTO loginDTO) {
    logger.info("用户登录请求: {}", loginDTO.getUsername());
    
    // 业务逻辑：验证用户名密码
    User user = checkUserAndPassword(loginDTO.getUsername(), loginDTO.getPassword());
    if (user == null) {
        logger.warn("登录失败: 用户名或密码错误");
        return Result.failure(2100); // 返回错误码，不包含message
    }
    
    // 业务逻辑：生成token
    String token = jwtUtil.generateToken(user);
    TokenVO tokenVO = new TokenVO();
    tokenVO.setToken(token);
    tokenVO.setUserInfo(convertToUserVO(user));
    
    logger.info("登录成功: username: {}", loginDTO.getUsername());
    return Result.success(2000, tokenVO); // 返回成功码和数据
}
```

### 3. Mapper层 (`mapper/` 和 `resources/mapper/`)

**职责：**
- 定义数据库操作方法
- 执行SQL查询
- 返回Entity对象

**注意：**
- Mapper接口定义在 `mapper/` 包中
- SQL映射文件在 `resources/mapper/` 目录中
- 通常不需要修改，除非需要新增数据库操作

**示例：**
```java
// UserMapper.java
User selectByUsername(String username);
User selectById(String id);
int insert(User user);
int update(User user);
```

### 4. 数据模型层

#### DTO (Data Transfer Object) - `model/dto/`
- 用于接收前端请求参数
- 包含参数验证注解（`@NotNull`, `@NotBlank`, `@Size` 等）

#### Entity - `model/entity/`
- 对应数据库表结构
- 用于Mapper层返回数据

#### VO (Value Object) - `model/vo/`
- 用于返回给前端的数据
- 不包含敏感信息（如密码）
- 可能包含计算字段

**转换关系：**
```
前端请求 → DTO → Service处理 → Entity (数据库) → VO → 前端响应
```

### 5. 前端API层 (`src/api/`)

**职责：**
- 定义API函数
- 调用axios发送请求
- 返回Promise

**示例：**
```javascript
export function login(loginData) {
  return request({
    url: API.USER.LOGIN,
    method: 'post',
    data: loginData
  })
}
```

---

## 标准开发流程

### 步骤1：确定接口需求

1. **查看接口文档（主要依据）：**
   - 查看 `openapi_new.yaml` 中的接口定义
   - 这是接口开发的主要依据，必须严格按照接口文档实现

2. **理解业务背景（参考）：**
   - 可选：阅读 `development-guide.md` 中相关模块的功能说明
   - 用于理解业务逻辑和功能背景
   - **注意：** 如果文档描述与接口定义不一致，以接口定义为准

3. **确定开发要素：**
   - HTTP方法和路径（来自接口文档）
   - 请求参数（创建DTO类，参考接口文档的requestBody）
   - 响应数据（创建VO类，参考接口文档的responses）
   - 成功码和失败码（参考 `code-message-mapping.md`）

### 步骤2：创建/修改DTO类

**位置：** `src/main/java/com/shangnantea/model/dto/`

**要求：**
- 类名以 `DTO` 结尾
- 包含参数验证注解
- 实现 `Serializable` 接口（可选）

**示例：**
```java
package com.shangnantea.model.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class LoginDTO implements Serializable {
    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 20, message = "用户名长度必须在3-20之间")
    private String username;
    
    @NotBlank(message = "密码不能为空")
    @Size(min = 6, max = 20, message = "密码长度必须在6-20之间")
    private String password;
    
    // getter和setter
}
```

### 步骤3：创建/修改VO类

**位置：** `src/main/java/com/shangnantea/model/vo/`

**要求：**
- 类名以 `VO` 结尾
- 不包含敏感信息
- 实现 `Serializable` 接口（可选）

**示例：**
```java
package com.shangnantea.model.vo.user;

public class TokenVO implements Serializable {
    private String token;
    private UserVO userInfo;
    
    // getter和setter
}
```

### 步骤4：在Service接口中定义方法

**位置：** `src/main/java/com/shangnantea/service/`

**要求：**
- 方法返回类型为 `Result<T>`
- 参数使用DTO类型
- 添加JavaDoc注释

**示例：**
```java
/**
 * 用户登录
 *
 * @param loginDTO 登录信息
 * @return 登录结果，包含token和用户信息
 */
Result<TokenVO> login(LoginDTO loginDTO);
```

### 步骤5：实现Service方法

**位置：** `src/main/java/com/shangnantea/service/impl/`

**步骤：**
1. 参数验证（如果DTO验证不够）
2. 业务逻辑处理
3. 调用Mapper进行数据库操作
4. 数据转换（Entity → VO）
5. 返回 `Result<T>`

**关键点：**
- 使用 `Result.success(code, data)` 返回成功
- 使用 `Result.failure(code)` 返回失败
- 记录日志
- 事务管理（需要时使用 `@Transactional`）

**示例：**
```java
@Override
public Result<TokenVO> login(LoginDTO loginDTO) {
    logger.info("用户登录请求: {}", loginDTO.getUsername());
    
    // 1. 业务逻辑：验证用户
    User user = checkUserAndPassword(loginDTO.getUsername(), loginDTO.getPassword());
    if (user == null) {
        logger.warn("登录失败: 用户名或密码错误");
        return Result.failure(2100);
    }
    
    // 2. 业务逻辑：检查状态
    if (user.getStatus() == 0) {
        logger.warn("登录失败: 用户已被禁用");
        return Result.failure(2100);
    }
    
    // 3. 业务逻辑：生成token
    String token = jwtUtil.generateToken(user);
    if (token == null) {
        logger.error("登录失败: Token生成失败");
        return Result.failure(2105);
    }
    
    // 4. 数据转换：Entity → VO
    TokenVO tokenVO = new TokenVO();
    tokenVO.setToken(token);
    tokenVO.setUserInfo(convertToUserVO(user));
    
    logger.info("登录成功: username: {}", loginDTO.getUsername());
    return Result.success(2000, tokenVO);
}
```

### 步骤6：在Controller中添加接口

**位置：** `src/main/java/com/shangnantea/controller/`

**要求：**
- 使用 `@PostMapping`, `@GetMapping`, `@PutMapping`, `@DeleteMapping` 等注解
- 参数使用 `@RequestBody @Valid DTO` 或 `@PathVariable`, `@RequestParam`
- 直接返回Service的 `Result<T>`
- 添加JavaDoc注释，包含路径和成功码/失败码

**示例：**
```java
/**
 * 用户登录
 * 路径: POST /user/login
 * 成功码: 2000, 失败码: 2100, 2105
 *
 * @param loginDTO 登录信息
 * @return 登录结果
 */
@PostMapping("/login")
public Result<TokenVO> login(@RequestBody @Valid LoginDTO loginDTO) {
    logger.info("用户登录请求: {}", loginDTO.getUsername());
    return userService.login(loginDTO);
}
```

### 步骤7：前端API函数（如需要）

**位置：** `shangnantea-web/src/api/`

**要求：**
- 在对应的模块文件中添加函数（如 `user.js`, `tea.js` 等）
- 使用 `request` 方法发送请求
- 添加JSDoc注释

**示例：**
```javascript
/**
 * 用户登录
 * @param {Object} loginData 登录数据 {username, password}
 * @returns {Promise} 登录结果
 */
export function login(loginData) {
  return request({
    url: API.USER.LOGIN,
    method: 'post',
    data: loginData
  })
}
```

### 步骤8：测试

1. **后端测试：**
   - 启动后端服务器
   - 使用Postman或Apifox测试接口
   - 验证返回的 `code` 和 `data` 格式

2. **前端测试：**
   - 启动前端服务器
   - 在浏览器中测试功能
   - 检查控制台日志

---

## 特殊接口类型开发指南

### 图片上传接口开发

基于用户头像上传功能的完整开发经验，适用于所有9个图片上传接口。

#### 接口特点

**与普通接口的区别：**
- 参数类型：使用 `MultipartFile` 而不是DTO
- 请求格式：`multipart/form-data` 而不是JSON
- 业务逻辑：涉及文件处理、存储、URL生成
- 返回格式：统一返回 `{url, path}` 格式

#### 开发流程

**步骤1：确定业务场景**

根据FILE-UPLOAD-SYSTEM-GUIDE.md，图片上传分为三种场景：
- **场景1**：直接存数据库（如头像、店铺Logo）
- **场景2**：先返回URL，稍后存储（如帖子图片、评价图片）
- **场景3**：上传+业务操作（如聊天图片消息）

**步骤2：Controller层实现**

```java
/**
 * 上传[业务]图片
 * 路径: POST /[模块]/[功能]/image
 * 成功码: [xxxx], 失败码: [xxxx, xxxx, xxxx]
 */
@PostMapping("/[功能]/image")
@RequiresLogin  // 必须添加权限验证
public Result<Map<String, Object>> upload[业务]Image(@RequestParam("file") MultipartFile file) {
    logger.info("上传[业务]图片请求, 文件名: {}", file.getOriginalFilename());
    return [模块]Service.upload[业务]Image(file);
}
```

**关键点：**
- 使用 `@RequestParam("file") MultipartFile file` 接收文件
- 必须添加 `@RequiresLogin` 权限验证
- 记录文件名日志便于调试

**步骤3：Service层实现（场景1：直接存数据库）**

```java
@Override
@Transactional(rollbackFor = Exception.class)  // 重要：添加事务
public Result<Map<String, Object>> upload[业务]Image(MultipartFile file) {
    try {
        // 1. 获取当前用户ID（权限验证）
        String userId = UserContext.getCurrentUserId();
        if (userId == null) {
            logger.warn("[业务]图片上传失败: 用户未登录");
            return Result.failure([失败码1]);
        }
        
        // 2. 验证用户是否存在（可选，根据业务需要）
        User user = getUserEntityById(userId);
        if (user == null) {
            logger.warn("[业务]图片上传失败: 用户不存在, userId: {}", userId);
            return Result.failure([失败码1]);
        }
        
        // 3. 调用工具类上传（硬编码type）
        String relativePath = FileUploadUtils.uploadImage(file, "[type]");
        
        // 4. 生成访问URL
        String accessUrl = FileUploadUtils.generateAccessUrl(relativePath, baseUrl);
        
        // 5. 更新数据库
        int result = [mapper].update[字段](userId, relativePath);
        if (result <= 0) {
            logger.error("[业务]图片上传失败: 数据库更新失败, userId: {}", userId);
            return Result.failure([失败码2]);
        }
        
        // 6. 构造返回数据
        Map<String, Object> responseData = new HashMap<>();
        responseData.put("url", accessUrl);
        responseData.put("path", relativePath);
        
        logger.info("[业务]图片上传成功: userId: {}, path: {}", userId, relativePath);
        return Result.success([成功码], responseData);
        
    } catch (BusinessException e) {
        logger.error("[业务]图片上传失败: 业务异常", e);
        return Result.failure([失败码3]);
    } catch (Exception e) {
        logger.error("[业务]图片上传失败: 系统异常", e);
        return Result.failure([失败码3]);
    }
}
```

**关键点：**
- 必须添加 `@Transactional` 事务注解
- 用户身份验证：`UserContext.getCurrentUserId()`
- 硬编码type：每个接口的type是固定的（如"avatars"）
- 统一返回格式：`{url, path}`
- 详细的日志记录和异常处理

**步骤4：Mapper层实现（场景1需要）**

```java
// Mapper接口
/**
 * 更新[业务]图片
 *
 * @param id     记录ID
 * @param [字段] 图片路径
 * @return 影响行数
 */
int update[字段](@Param("id") String id, @Param("[字段]") String [字段]);
```

```xml
<!-- XML映射 -->
<update id="update[字段]">
    UPDATE [表名]
    SET [字段] = #{[字段],jdbcType=VARCHAR},
    update_time = now()
    WHERE id = #{id,jdbcType=VARCHAR}
</update>
```

**步骤5：配置检查**

确保以下配置已正确设置：

```yaml
# application.yml
app:
  base-url: http://localhost:8080  # 必须配置
```

```java
// WebMvcConfig.java
@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry.addResourceHandler("/files/**")
            .addResourceLocations("file:" + System.getProperty("user.dir") + "/files/");
}

@Override
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(jwtInterceptor)
            .excludePathPatterns("/files/**");  // 排除文件访问
}
```

#### 前端对接要点

**API层：**
```javascript
export function upload[业务]Image(file) {
  const formData = new FormData()
  formData.append('file', file)  // 参数名必须是'file'
  
  return request({
    url: API.[模块].[接口常量],
    method: 'post',
    data: formData,
    headers: {
      'Content-Type': 'multipart/form-data'  // 必须设置
    }
  })
}
```

**组件层：**
```javascript
// 上传前验证
const beforeUpload = (file) => {
  const isImage = file.type.startsWith('image/')
  const isLt2M = file.size / 1024 / 1024 < 2
  
  if (!isImage) {
    showByCode([失败码1]) // 使用统一状态码系统
    return false
  }
  if (!isLt2M) {
    showByCode([失败码2])
    return false
  }
  return true
}

// 上传处理
const handleUpload = async (options) => {
  try {
    const res = await store.dispatch('[模块]/upload[业务]Image', options.file)
    showByCode(res.code)  // 统一状态码处理
    
    if (isSuccess(res.code)) {
      imageUrl.value = res.data.url  // 使用返回的URL
    }
  } catch (error) {
    console.error('上传失败:', error)
  }
}
```

#### 常见问题与解决方案

**Q1：文件上传失败，提示权限错误**
- 检查Controller是否添加了 `@RequiresLogin`
- 确认JWT token是否有效
- 验证 `UserContext.getCurrentUserId()` 是否返回正确值

**Q2：图片无法访问，返回404**
- 检查WebMvcConfig中的静态资源映射
- 确认JWT拦截器排除了 `/files/**` 路径
- 验证文件是否真实存在于指定路径

**Q3：数据库更新失败**
- 检查Mapper方法是否正确定义
- 确认XML映射文件中的SQL语句
- 验证数据库字段长度是否足够（建议VARCHAR(255)）

**Q4：baseUrl配置问题**
- 确保application.yml中配置了 `app.base-url`
- 检查Service层是否正确注入 `@Value("${app.base-url}")`

#### 9个图片上传接口对照表

| 接口 | Type | 场景 | 数据库操作 | 特殊说明 |
|------|------|------|------------|----------|
| uploadAvatar | avatars | 场景1 | users.avatar | 用户头像，已完成 |
| uploadCertificationImage | certifications | 场景1 | shop_certifications | 商家认证图片 |
| uploadTeaImages | teas | 场景1 | tea_images表 | 茶叶图片，专用表 |
| uploadShopLogo | logos | 场景1 | shops.logo | 店铺Logo |
| uploadShopBanner | shop-banners | 场景1 | shop_banners表 | 店铺轮播图 |
| uploadReviewImage | reviews | 场景2 | 稍后存储 | 评价图片，先返回URL |
| uploadBanner | forum-banners | 场景1 | home_contents | 论坛轮播图 |
| sendImageMessage | messages | 场景3 | chat_messages | 聊天图片+创建消息 |
| uploadPostImage | posts | 场景2 | 稍后存储 | 帖子图片，先返回URL |

---

## 代码示例

### 完整示例：用户注册功能

#### 1. DTO类
```java
// RegisterDTO.java
package com.shangnantea.model.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public class RegisterDTO implements Serializable {
    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 20, message = "用户名长度必须在3-20之间")
    private String username;
    
    @NotBlank(message = "密码不能为空")
    @Size(min = 6, max = 20, message = "密码长度必须在6-20之间")
    private String password;
    
    @NotBlank(message = "确认密码不能为空")
    private String confirmPassword;
    
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    private String phone;
    
    @Email(message = "邮箱格式不正确")
    private String email;
    
    // getter和setter
}
```

#### 2. VO类
```java
// UserVO.java
package com.shangnantea.model.vo.user;

public class UserVO implements Serializable {
    private String id;
    private String username;
    private String phone;
    private String email;
    private Integer role;
    private Integer status;
    // 不包含password字段
    
    // getter和setter
}
```

#### 3. Service接口
```java
// UserService.java
Result<UserVO> register(RegisterDTO registerDTO);
```

#### 4. Service实现
```java
// UserServiceImpl.java
@Override
@Transactional(rollbackFor = Exception.class)
public Result<UserVO> register(RegisterDTO registerDTO) {
    logger.info("用户注册请求: {}", registerDTO.getUsername());
    
    // 1. 检查用户名是否已存在
    if (isUserExist(registerDTO.getUsername())) {
        logger.warn("注册失败: 用户名已存在");
        return Result.failure(2101);
    }
    
    // 2. 验证密码一致性
    if (!registerDTO.getPassword().equals(registerDTO.getConfirmPassword())) {
        logger.warn("注册失败: 两次输入的密码不一致");
        return Result.failure(2101);
    }
    
    // 3. 转换为Entity
    User user = new User();
    user.setUsername(registerDTO.getUsername());
    user.setPassword(registerDTO.getPassword());
    user.setPhone(registerDTO.getPhone());
    user.setEmail(registerDTO.getEmail());
    
    // 4. 设置默认值
    user.setId(generateUserId());
    user.setPassword(passwordEncoder.encode(user.getPassword()));
    user.setRole(2); // 普通用户
    user.setStatus(1); // 正常状态
    user.setIsDeleted(0);
    user.setCreateTime(new Date());
    user.setUpdateTime(new Date());
    
    // 5. 保存到数据库
    int result = userMapper.insert(user);
    if (result <= 0) {
        logger.error("注册失败: 数据库插入失败");
        return Result.failure(2101);
    }
    
    logger.info("用户注册成功: username: {}, userId: {}", 
                registerDTO.getUsername(), user.getId());
    return Result.success(2001, convertToUserVO(user));
}
```

#### 5. Controller
```java
// UserController.java
@PostMapping("/register")
public Result<UserVO> register(@RequestBody @Valid RegisterDTO registerDTO) {
    logger.info("用户注册请求: {}", registerDTO.getUsername());
    return userService.register(registerDTO);
}
```

#### 6. 前端API
```javascript
// user.js
export function register(registerData) {
  return request({
    url: API.USER.REGISTER,
    method: 'post',
    data: registerData
  })
}
```

---

## 注意事项与最佳实践

### 1. 错误码使用

- **参考文档：** `code-message-mapping.md`
- **使用方式：** `Result.failure(错误码)`，不包含message
- **前端处理：** 前端根据 `code` 映射到对应的错误消息

### 2. 日志记录

- **Info级别：** 记录正常业务流程（如：用户登录请求、操作成功）
- **Warn级别：** 记录业务异常（如：登录失败、参数错误）
- **Error级别：** 记录系统异常（如：数据库操作失败、Token生成失败）

### 3. 事务管理

- **使用场景：** 涉及多个数据库操作的方法
- **注解：** `@Transactional(rollbackFor = Exception.class)`
- **位置：** Service实现类的方法上

### 4. 参数验证

- **DTO验证：** 使用 `@Valid` 和验证注解（`@NotBlank`, `@Size` 等）
- **业务验证：** 在Service层进行（如：用户名是否存在、密码是否正确）

### 5. 数据转换

- **Entity → VO：** 在Service层进行转换
- **转换方法：** 创建私有方法 `convertToVO(Entity entity)`
- **敏感信息：** VO中不包含密码等敏感字段

### 6. 异常处理

- **业务异常：** 在Service层处理，返回 `Result.failure(code)`
- **系统异常：** 由 `GlobalExceptionHandler` 统一处理
- **Controller层：** 不处理异常，直接抛出

### 7. 代码规范

- **命名：** DTO以 `DTO` 结尾，VO以 `VO` 结尾
- **注释：** 所有公共方法必须有JavaDoc注释
- **格式：** 使用4个空格缩进，每行不超过120个字符

---

## 开发检查清单

在完成一个接口开发后，请检查以下项目：

### 后端检查

- [ ] DTO类已创建，包含参数验证注解（普通接口）
- [ ] VO类已创建，不包含敏感信息（普通接口）
- [ ] Service接口已定义方法，返回 `Result<T>`
- [ ] Service实现已完成，包含业务逻辑和错误处理
- [ ] Controller已添加接口，直接返回Service的 `Result<T>`
- [ ] 日志记录已添加（info/warn/error）
- [ ] 错误码已确认（参考 `code-message-mapping.md`）
- [ ] 事务管理已添加（如需要）
- [ ] 代码已通过编译
- [ ] 接口已通过Postman/Apifox测试

#### 图片上传接口额外检查

- [ ] Controller使用 `@RequestParam("file") MultipartFile file` 接收文件
- [ ] Controller添加了 `@RequiresLogin` 权限验证
- [ ] Service层添加了 `@Transactional` 事务注解
- [ ] Service层正确获取用户ID：`UserContext.getCurrentUserId()`
- [ ] Service层硬编码了正确的type参数
- [ ] Service层返回统一格式：`{url, path}`
- [ ] Mapper层添加了更新方法（场景1需要）
- [ ] XML映射添加了对应SQL（场景1需要）
- [ ] application.yml配置了 `app.base-url`
- [ ] WebMvcConfig配置了静态资源映射
- [ ] WebMvcConfig排除了 `/files/**` 路径
- [ ] 文件上传功能已测试（包括文件访问）

### 前端检查（如需要）

- [ ] API函数已添加到对应的模块文件
- [ ] API常量已添加到 `apiConstants.js`
- [ ] 前端调用已测试

### 文档检查

- [ ] 接口路径和HTTP方法已确认
- [ ] 成功码和失败码已记录
- [ ] JavaDoc注释已添加

---

## 常见问题

### Q1: Controller中需要处理异常吗？

**A:** 不需要。异常由 `GlobalExceptionHandler` 统一处理，Controller直接返回Service的 `Result<T>`。

### Q2: Service方法必须返回 `Result<T>` 吗？

**A:** 是的。所有对外接口的Service方法必须返回 `Result<T>`，内部辅助方法可以返回其他类型。

### Q3: 如何确定错误码？

**A:** 参考 `code-message-mapping.md` 文档，根据业务场景选择合适的错误码。

### Q4: 什么时候需要事务管理？

**A:** 当方法涉及多个数据库操作，且需要保证原子性时，使用 `@Transactional`。

### Q6: 图片上传接口有什么特殊要求？

**A:** 图片上传接口有以下特殊要求：
- Controller使用 `@RequestParam("file") MultipartFile file` 接收文件
- 必须添加 `@RequiresLogin` 权限验证
- Service层必须添加 `@Transactional` 事务注解
- 需要配置静态资源映射和JWT拦截器排除
- 返回格式固定为 `{url, path}`
- 详细开发指南参考"特殊接口类型开发指南"章节

### Q7: 如何确定图片上传的type参数？

**A:** 每个图片上传接口的type是固定的，参考FILE-UPLOAD-SYSTEM-GUIDE.md中的对照表，如头像上传使用"avatars"，帖子图片使用"posts"。

### Q8: 图片上传的三种业务场景有什么区别？

**A:** 
- **场景1**：直接存数据库，需要Mapper操作，如头像上传
- **场景2**：先返回URL，稍后存储，如帖子图片
- **场景3**：上传+业务操作，如聊天图片消息

---

## 参考文件

### 核心参考文档

- **OpenAPI接口文档：** `openapi_new.yaml`（主要参考）
  - 这是接口开发的主要依据
  - 定义了所有接口的路径、方法、参数、响应格式
  - 必须严格按照接口文档实现功能

- **消息码映射：** `shangnantea-web/docs/tasks/code-message-mapping.md`
  - 定义了所有成功码和失败码
  - 用于确定接口返回的错误码

### 功能理解参考文档

- **前端开发指南：** `shangnantea-web/docs/development-guide.md`
  - **用途：** 用于理解项目整体功能和业务逻辑
  - **说明：** 
    - 该文档是对项目各个功能模块的大致说明
    - 主要用于加深对接口所需功能的理解
    - 帮助开发者理解业务背景，避免实现逻辑与预期偏差过大
  - **注意事项：**
    - ⚠️ 该文档是给前端开发做指导的，用语言描述的是最终产品形态
    - ⚠️ 某些功能描述可能超出了实际接口定义的范围
    - ⚠️ **接口开发应以 `openapi_new.yaml` 为准**，围绕接口文档实现接口的本职功能
    - ⚠️ 该文档仅作为理解参考，不能替代接口文档作为开发依据
  - **使用建议：**
    - 开发前先阅读相关模块的功能说明，理解业务背景
    - 然后对照 `openapi_new.yaml` 中的接口定义进行开发
    - 如果文档描述与接口定义不一致，以接口定义为准

### 代码示例参考

- **登录示例：** `UserController.login()`, `UserService.login()`
- **注册示例：** `UserController.register()`, `UserService.register()`

---

**文档版本：** v1.1  
**最后更新：** 2026-01-21  
**基于功能：** 用户登录、用户注册、用户头像上传

