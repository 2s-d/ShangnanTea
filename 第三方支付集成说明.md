# 第三方支付集成说明

## 重要说明

**我们绝对不会自己开发支付系统！**
- ✅ 必须使用第三方支付平台（支付宝、微信支付等）
- ❌ 自己开发支付系统安全隐患太大
- ✅ 第三方支付平台提供完整的安全保障和资金监管

**第三方支付不是调用一个接口就完成的！**
- 支付流程需要调用多个接口：创建订单、查询订单、关闭订单等
- 退款流程需要调用多个接口：申请退款、查询退款等
- 还需要实现回调接口接收异步通知

---

## 问题澄清

### 问题1：余额支付能否通过第三方接口解决？

**答案：不能！余额支付和第三方支付是两个不同的概念。**

#### 两种"余额"的区别

| 类型 | 第三方平台余额 | 系统内部余额 |
|------|--------------|------------|
| **例子** | 支付宝余额、微信零钱 | 会员余额、充值余额 |
| **谁管理** | 第三方平台（支付宝、微信） | 我们的系统 |
| **余额不足处理** | 第三方平台自动提示 | 我们的系统验证 |
| **需要我们实现** | ❌ 不需要 | ✅ 需要 |
| **第三方接口能解决** | ✅ 能 | ❌ 不能 |

#### 当前代码中的"balance"是什么？

```java
if ("balance".equals(paymentMethod)) {
    // TODO: 实际应该查询用户余额表
    // 这里简化处理，假设余额不足
    return Result.failure(5120); // 余额不足
}
```

**这里的"balance"指的是系统内部余额，不是第三方平台余额！**

#### 推荐方案

**如果集成第三方支付，建议：**
1. ❌ 移除"balance"支付方式
2. ✅ 只支持第三方支付：alipay（支付宝）、wechat（微信）
3. ✅ 用户在第三方平台选择使用余额或银行卡，由第三方平台处理

**如果要支持系统内部余额，需要：**
1. 创建用户余额表
2. 实现余额充值功能（可以通过第三方支付充值）
3. 实现余额查询和扣减逻辑
4. 实现余额支付的事务处理

---

### 问题2：退款操作是由第三方接口完全处理吗？

**答案：不是！需要我们主动调用第三方接口，并处理回调。**

#### 完整的退款流程

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 用户申请退款                                              │
│    - 调用 refundOrder 方法                                   │
│    - 订单状态：refundStatus = 1（申请中）                    │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. 商家审核                                                  │
│    - 调用 processRefund 方法                                │
│    - 商家选择：同意 or 拒绝                                  │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. 如果同意，我们主动调用第三方退款接口 ⭐ 关键步骤          │
│    - 根据 order.paymentMethod 选择支付平台                   │
│    - 调用支付宝/微信的退款接口                               │
│    - 传入：订单号、退款金额、退款原因                        │
│    - 订单状态：refundStatus = 2（已同意，处理中）            │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. 第三方平台处理退款（异步）                                │
│    - 支付宝/微信内部处理退款                                 │
│    - 验证订单、验证金额、执行退款                            │
│    - 这个过程可能需要几秒到几分钟                            │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. 第三方平台回调通知我们 ⭐ 关键步骤                         │
│    - 第三方平台调用我们的回调接口                            │
│    - 传入：退款结果（成功/失败）、退款时间                   │
│    - 我们需要验证回调签名                                    │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. 我们更新订单状态                                          │
│    - 如果退款成功：order.status = 6（已退款）                │
│    - 如果退款失败：order.refundStatus = 3（已拒绝）          │
│    - 记录退款时间：order.refundProcessTime                   │
└─────────────────────────────────────────────────────────────┘
```

#### 关键点

1. **第三方平台不会自动退款**
   - 需要我们主动调用退款接口
   - 不调用就不会退款

2. **退款是异步的**
   - 调用退款接口后，不会立即完成
   - 需要等待第三方平台处理
   - 通过回调接口接收结果

3. **需要实现两个接口**
   - 主动调用：我们调用第三方的退款接口
   - 被动接收：第三方调用我们的回调接口

4. **退款金额原路返回**
   - 用户用支付宝支付，退款到支付宝
   - 用户用微信支付，退款到微信
   - 由第三方平台自动处理

---

## 集成第三方支付后的完整实现

### 第三方支付涉及的所有接口

#### 支付宝为例，需要调用的接口：

| 接口名称 | 用途 | 调用时机 |
|---------|------|---------|
| alipay.trade.page.pay | 创建支付订单 | 用户点击支付时 |
| alipay.trade.query | 查询支付状态 | 主动查询订单状态 |
| alipay.trade.close | 关闭支付订单 | 用户取消支付时 |
| alipay.trade.refund | 申请退款 | 商家同意退款时 |
| alipay.trade.refund.query | 查询退款状态 | 主动查询退款状态 |
| 支付回调接口 | 接收支付结果 | 支付宝异步通知 |
| 退款回调接口 | 接收退款结果 | 支付宝异步通知 |

**微信支付类似，也需要多个接口。**

---

### 1. 支付流程（需要调用多个接口）

#### 1.1 创建支付订单

```java
@Override
@Transactional
public Result<Object> payOrder(Map<String, Object> data) {
    // ... 前面的验证逻辑 ...
    
    // 验证支付方式
    String paymentMethod = (String) data.get("paymentMethod");
    if (!"alipay".equals(paymentMethod) && !"wechat".equals(paymentMethod)) {
        logger.warn("支付订单失败: 不支持的支付方式: {}", paymentMethod);
        return Result.failure(5120); // 不支持的支付方式
    }
    
    // 调用第三方支付接口创建支付订单
    try {
        String payUrl = null;
        if ("alipay".equals(paymentMethod)) {
            // 调用支付宝的 alipay.trade.page.pay 接口
            // 传入：订单号、金额、商品名称、回调地址等
            payUrl = alipayService.createPayment(
                order.getId(),              // 订单号
                order.getTotalAmount(),     // 金额
                order.getTeaName(),         // 商品名称
                "http://yourdomain.com/payment/callback"  // 回调地址
            );
        } else if ("wechat".equals(paymentMethod)) {
            // 调用微信的统一下单接口
            payUrl = wechatPayService.createPayment(
                order.getId(), 
                order.getTotalAmount(),
                order.getTeaName(),
                "http://yourdomain.com/payment/callback"
            );
        }
        
        // 返回支付URL给前端
        Map<String, Object> responseData = new HashMap<>();
        responseData.put("orderId", orderId);
        responseData.put("payUrl", payUrl); // 前端跳转到这个URL进行支付
        
        logger.info("支付订单创建成功: orderId={}, payUrl={}", orderId, payUrl);
        return Result.success(5007, responseData);
        
    } catch (Exception e) {
        logger.error("调用支付接口失败: orderId={}, error={}", orderId, e.getMessage());
        return Result.failure(5117);
    }
}
```

#### 1.2 支付回调接口（接收支付结果）

```java
/**
 * 支付宝/微信支付回调接口
 * 第三方平台会异步调用这个接口通知支付结果
 */
@PostMapping("/payment/callback")
public String handlePaymentCallback(@RequestBody Map<String, Object> callbackData) {
    try {
        // 1. 验证回调签名（防止伪造）
        // 支付宝和微信都会提供签名验证方法
        if (!paymentService.verifySignature(callbackData)) {
            logger.warn("支付回调签名验证失败");
            return "fail";
        }
        
        // 2. 解析回调数据
        String orderId = (String) callbackData.get("out_trade_no"); // 我们的订单号
        String tradeNo = (String) callbackData.get("trade_no");     // 第三方交易号
        String paymentStatus = (String) callbackData.get("trade_status");
        
        // 3. 查询订单
        Order order = orderMapper.selectById(orderId);
        if (order == null) {
            logger.warn("支付回调: 订单不存在: orderId={}", orderId);
            return "fail";
        }
        
        // 4. 更新订单状态
        if ("TRADE_SUCCESS".equals(paymentStatus) || "TRADE_FINISHED".equals(paymentStatus)) {
            order.setStatus(Order.STATUS_PENDING_SHIPMENT); // 待发货
            order.setPaymentTime(new Date());
            order.setPaymentTransactionId(tradeNo); // 保存第三方交易号
            orderMapper.updateById(order);
            logger.info("支付成功: orderId={}, tradeNo={}", orderId, tradeNo);
        }
        
        // 5. 返回success给第三方平台，表示我们已经处理
        return "success";
        
    } catch (Exception e) {
        logger.error("处理支付回调失败", e);
        return "fail";
    }
}
```

#### 1.3 主动查询支付状态（可选）

```java
/**
 * 主动查询订单支付状态
 * 用于前端轮询或用户刷新页面时查询
 */
@GetMapping("/order/{id}/payment-status")
public Result<Object> queryPaymentStatus(@PathVariable String id) {
    try {
        // 1. 查询订单
        Order order = orderMapper.selectById(id);
        if (order == null) {
            return Result.failure(5114);
        }
        
        // 2. 如果订单已支付，直接返回
        if (order.getStatus() >= Order.STATUS_PENDING_SHIPMENT) {
            return Result.success(200, "已支付");
        }
        
        // 3. 调用第三方接口查询支付状态
        // 调用支付宝的 alipay.trade.query 接口
        // 或微信的订单查询接口
        String paymentStatus = paymentService.queryPaymentStatus(id);
        
        if ("TRADE_SUCCESS".equals(paymentStatus)) {
            // 支付成功，更新订单状态
            order.setStatus(Order.STATUS_PENDING_SHIPMENT);
            order.setPaymentTime(new Date());
            orderMapper.updateById(order);
            return Result.success(200, "已支付");
        }
        
        return Result.success(200, "未支付");
        
    } catch (Exception e) {
        logger.error("查询支付状态失败", e);
        return Result.failure(5117);
    }
}
```

#### 1.4 取消支付（关闭订单）

```java
/**
 * 用户取消支付时，需要关闭第三方支付订单
 */
@PostMapping("/order/{id}/cancel-payment")
public Result<Boolean> cancelPayment(@PathVariable String id) {
    try {
        // 1. 查询订单
        Order order = orderMapper.selectById(id);
        if (order == null) {
            return Result.failure(5114);
        }
        
        // 2. 只有待支付状态可以取消
        if (order.getStatus() != Order.STATUS_PENDING_PAYMENT) {
            return Result.failure(5121);
        }
        
        // 3. 调用第三方接口关闭支付订单
        // 调用支付宝的 alipay.trade.close 接口
        // 或微信的关单接口
        paymentService.closePayment(id);
        
        // 4. 更新订单状态为已取消
        order.setStatus(Order.STATUS_CANCELLED);
        order.setCancelTime(new Date());
        orderMapper.updateById(order);
        
        logger.info("取消支付成功: orderId={}", id);
        return Result.success(5008, true);
        
    } catch (Exception e) {
        logger.error("取消支付失败", e);
        return Result.failure(5121);
    }
}
```

---

### 2. 退款流程（需要调用多个接口）

#### 2.1 申请退款

```java
@Override
@Transactional
public Result<Boolean> processRefund(String id, Map<String, Object> data) {
    // ... 前面的验证逻辑 ...
    
    if (approve) {
        // 同意退款
        order.setRefundStatus(2); // 2:已同意，处理中
        order.setUpdateTime(new Date());
        
        int rows = orderMapper.updateById(order);
        if (rows > 0) {
            // 调用第三方支付平台的退款接口
            try {
                if ("alipay".equals(order.getPaymentMethod())) {
                    // 调用支付宝的 alipay.trade.refund 接口
                    // 传入：订单号、退款金额、退款原因
                    alipayService.refund(
                        order.getId(),              // 订单号
                        order.getTotalAmount(),     // 退款金额
                        order.getRefundReason()     // 退款原因
                    );
                } else if ("wechat".equals(order.getPaymentMethod())) {
                    // 调用微信的退款接口
                    wechatPayService.refund(
                        order.getId(), 
                        order.getTotalAmount(), 
                        order.getRefundReason()
                    );
                }
                
                logger.info("退款请求已提交: orderId={}, amount={}", id, order.getTotalAmount());
                return Result.success(5012, true); // 已同意退款申请，等待处理
                
            } catch (Exception e) {
                logger.error("调用退款接口失败: orderId={}, error={}", id, e.getMessage());
                // 退款接口调用失败，回滚订单状态
                order.setRefundStatus(1); // 恢复为申请中
                orderMapper.updateById(order);
                return Result.failure(5131);
            }
        }
    } else {
        // 拒绝退款
        order.setRefundStatus(3); // 3:已拒绝
        order.setRefundRejectReason(rejectReason);
        order.setRefundProcessTime(new Date());
        order.setUpdateTime(new Date());
        
        int rows = orderMapper.updateById(order);
        if (rows > 0) {
            logger.info("拒绝退款成功: orderId={}, userId={}, reason={}", id, userId, rejectReason);
            return Result.success(5013, true); // 已拒绝退款申请
        }
    }
    
    return Result.failure(5131);
}
```

#### 2.2 退款回调接口（接收退款结果）

```java
/**
 * 支付宝/微信退款回调接口
 * 第三方平台会异步调用这个接口通知退款结果
 */
@PostMapping("/payment/refund/callback")
public String handleRefundCallback(@RequestBody Map<String, Object> callbackData) {
    try {
        // 1. 验证回调签名
        if (!paymentService.verifySignature(callbackData)) {
            logger.warn("退款回调签名验证失败");
            return "fail";
        }
        
        // 2. 解析回调数据
        String orderId = (String) callbackData.get("out_trade_no");
        String refundStatus = (String) callbackData.get("refund_status");
        
        // 3. 查询订单
        Order order = orderMapper.selectById(orderId);
        if (order == null) {
            logger.warn("退款回调: 订单不存在: orderId={}", orderId);
            return "fail";
        }
        
        // 4. 更新订单状态
        if ("REFUND_SUCCESS".equals(refundStatus)) {
            order.setStatus(Order.STATUS_REFUNDED); // 已退款
            order.setRefundProcessTime(new Date());
            orderMapper.updateById(order);
            logger.info("退款成功: orderId={}", orderId);
        } else {
            order.setRefundStatus(3); // 退款失败
            orderMapper.updateById(order);
            logger.warn("退款失败: orderId={}, status={}", orderId, refundStatus);
        }
        
        return "success"; // 返回给第三方平台
        
    } catch (Exception e) {
        logger.error("处理退款回调失败", e);
        return "fail";
    }
}
```

#### 2.3 主动查询退款状态（可选）

```java
/**
 * 主动查询退款状态
 * 用于商家或用户查询退款进度
 */
@GetMapping("/order/{id}/refund-status")
public Result<Object> queryRefundStatus(@PathVariable String id) {
    try {
        // 1. 查询订单
        Order order = orderMapper.selectById(id);
        if (order == null) {
            return Result.failure(5114);
        }
        
        // 2. 如果退款已完成，直接返回
        if (order.getStatus() == Order.STATUS_REFUNDED) {
            return Result.success(200, "退款成功");
        }
        
        // 3. 调用第三方接口查询退款状态
        // 调用支付宝的 alipay.trade.refund.query 接口
        // 或微信的退款查询接口
        String refundStatus = paymentService.queryRefundStatus(id);
        
        if ("REFUND_SUCCESS".equals(refundStatus)) {
            // 退款成功，更新订单状态
            order.setStatus(Order.STATUS_REFUNDED);
            order.setRefundProcessTime(new Date());
            orderMapper.updateById(order);
            return Result.success(200, "退款成功");
        }
        
        return Result.success(200, "退款处理中");
        
    } catch (Exception e) {
        logger.error("查询退款状态失败", e);
        return Result.failure(5133);
    }
}
```

---

### 3. PaymentService 封装层

为了更好地管理第三方支付接口，建议创建一个PaymentService：

```java
@Service
public class PaymentService {
    
    @Autowired
    private AlipayClient alipayClient;
    
    @Autowired
    private WechatPayClient wechatPayClient;
    
    /**
     * 创建支付订单
     */
    public String createPayment(String paymentMethod, String orderId, BigDecimal amount, String subject, String notifyUrl) {
        if ("alipay".equals(paymentMethod)) {
            return createAlipayPayment(orderId, amount, subject, notifyUrl);
        } else if ("wechat".equals(paymentMethod)) {
            return createWechatPayment(orderId, amount, subject, notifyUrl);
        }
        throw new IllegalArgumentException("不支持的支付方式: " + paymentMethod);
    }
    
    /**
     * 创建支付宝支付订单
     */
    private String createAlipayPayment(String orderId, BigDecimal amount, String subject, String notifyUrl) {
        // 调用支付宝 SDK
        // alipay.trade.page.pay 接口
        // 返回支付URL
    }
    
    /**
     * 创建微信支付订单
     */
    private String createWechatPayment(String orderId, BigDecimal amount, String subject, String notifyUrl) {
        // 调用微信支付 SDK
        // 统一下单接口
        // 返回支付URL
    }
    
    /**
     * 查询支付状态
     */
    public String queryPaymentStatus(String orderId) {
        // 调用 alipay.trade.query 或微信订单查询接口
    }
    
    /**
     * 关闭支付订单
     */
    public void closePayment(String orderId) {
        // 调用 alipay.trade.close 或微信关单接口
    }
    
    /**
     * 申请退款
     */
    public void refund(String paymentMethod, String orderId, BigDecimal amount, String reason) {
        if ("alipay".equals(paymentMethod)) {
            refundAlipay(orderId, amount, reason);
        } else if ("wechat".equals(paymentMethod)) {
            refundWechat(orderId, amount, reason);
        }
    }
    
    /**
     * 支付宝退款
     */
    private void refundAlipay(String orderId, BigDecimal amount, String reason) {
        // 调用支付宝 SDK
        // alipay.trade.refund 接口
    }
    
    /**
     * 微信退款
     */
    private void refundWechat(String orderId, BigDecimal amount, String reason) {
        // 调用微信支付 SDK
        // 退款接口
    }
    
    /**
     * 查询退款状态
     */
    public String queryRefundStatus(String orderId) {
        // 调用 alipay.trade.refund.query 或微信退款查询接口
    }
    
    /**
     * 验证回调签名
     */
    public boolean verifySignature(Map<String, Object> callbackData) {
        // 使用支付宝或微信提供的签名验证方法
        // 防止回调被伪造
    }
}
```

---

## 总结

### 第三方支付涉及的所有接口

#### 我们需要调用的第三方接口：

| 接口类型 | 接口名称 | 用途 | 是否必须 |
|---------|---------|------|---------|
| **支付相关** | alipay.trade.page.pay | 创建支付订单 | ✅ 必须 |
| | alipay.trade.query | 查询支付状态 | ⚠️ 建议 |
| | alipay.trade.close | 关闭支付订单 | ⚠️ 建议 |
| **退款相关** | alipay.trade.refund | 申请退款 | ✅ 必须 |
| | alipay.trade.refund.query | 查询退款状态 | ⚠️ 建议 |

#### 我们需要实现的回调接口：

| 接口类型 | 接口名称 | 用途 | 是否必须 |
|---------|---------|------|---------|
| **支付回调** | /payment/callback | 接收支付结果通知 | ✅ 必须 |
| **退款回调** | /payment/refund/callback | 接收退款结果通知 | ✅ 必须 |

**总计**：至少需要调用 **2个第三方接口**（创建支付、申请退款），实现 **2个回调接口**（支付回调、退款回调）

---

### 余额支付

| 问题 | 答案 |
|------|------|
| 第三方接口能解决余额不足问题吗？ | ✅ 能，但仅限于第三方平台的余额（支付宝余额、微信零钱） |
| 第三方接口能解决系统内部余额吗？ | ❌ 不能，需要我们自己实现 |
| 当前代码的"balance"是什么？ | 系统内部余额，不是第三方平台余额 |
| 推荐方案 | 移除"balance"，只支持alipay和wechat |

### 退款操作

| 问题 | 答案 |
|------|------|
| 第三方平台会自动退款吗？ | ❌ 不会，需要我们主动调用退款接口 |
| 退款是同步还是异步？ | 异步，需要通过回调接口接收结果 |
| 需要实现几个接口？ | 2个：主动调用退款接口 + 被动接收回调接口 |
| 退款金额去哪里？ | 原路返回（支付宝退到支付宝，微信退到微信） |

### 关键点

1. **余额支付**：第三方接口只能处理第三方平台的余额，不能处理我们系统内部的余额
2. **退款操作**：需要我们主动调用第三方接口，不是第三方自动处理
3. **异步处理**：支付和退款都是异步的，需要实现回调接口
4. **签名验证**：回调接口必须验证签名，防止伪造
