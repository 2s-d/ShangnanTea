# 第三方支付集成说明

## 问题澄清

### 问题1：余额支付能否通过第三方接口解决？

**答案：不能！余额支付和第三方支付是两个不同的概念。**

#### 两种"余额"的区别

| 类型 | 第三方平台余额 | 系统内部余额 |
|------|--------------|------------|
| **例子** | 支付宝余额、微信零钱 | 会员余额、充值余额 |
| **谁管理** | 第三方平台（支付宝、微信） | 我们的系统 |
| **余额不足处理** | 第三方平台自动提示 | 我们的系统验证 |
| **需要我们实现** | ❌ 不需要 | ✅ 需要 |
| **第三方接口能解决** | ✅ 能 | ❌ 不能 |

#### 当前代码中的"balance"是什么？

```java
if ("balance".equals(paymentMethod)) {
    // TODO: 实际应该查询用户余额表
    // 这里简化处理，假设余额不足
    return Result.failure(5120); // 余额不足
}
```

**这里的"balance"指的是系统内部余额，不是第三方平台余额！**

#### 推荐方案

**如果集成第三方支付，建议：**
1. ❌ 移除"balance"支付方式
2. ✅ 只支持第三方支付：alipay（支付宝）、wechat（微信）
3. ✅ 用户在第三方平台选择使用余额或银行卡，由第三方平台处理

**如果要支持系统内部余额，需要：**
1. 创建用户余额表
2. 实现余额充值功能（可以通过第三方支付充值）
3. 实现余额查询和扣减逻辑
4. 实现余额支付的事务处理

---

### 问题2：退款操作是由第三方接口完全处理吗？

**答案：不是！需要我们主动调用第三方接口，并处理回调。**

#### 完整的退款流程

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 用户申请退款                                              │
│    - 调用 refundOrder 方法                                   │
│    - 订单状态：refundStatus = 1（申请中）                    │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. 商家审核                                                  │
│    - 调用 processRefund 方法                                │
│    - 商家选择：同意 or 拒绝                                  │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. 如果同意，我们主动调用第三方退款接口 ⭐ 关键步骤          │
│    - 根据 order.paymentMethod 选择支付平台                   │
│    - 调用支付宝/微信的退款接口                               │
│    - 传入：订单号、退款金额、退款原因                        │
│    - 订单状态：refundStatus = 2（已同意，处理中）            │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. 第三方平台处理退款（异步）                                │
│    - 支付宝/微信内部处理退款                                 │
│    - 验证订单、验证金额、执行退款                            │
│    - 这个过程可能需要几秒到几分钟                            │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. 第三方平台回调通知我们 ⭐ 关键步骤                         │
│    - 第三方平台调用我们的回调接口                            │
│    - 传入：退款结果（成功/失败）、退款时间                   │
│    - 我们需要验证回调签名                                    │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. 我们更新订单状态                                          │
│    - 如果退款成功：order.status = 6（已退款）                │
│    - 如果退款失败：order.refundStatus = 3（已拒绝）          │
│    - 记录退款时间：order.refundProcessTime                   │
└─────────────────────────────────────────────────────────────┘
```

#### 关键点

1. **第三方平台不会自动退款**
   - 需要我们主动调用退款接口
   - 不调用就不会退款

2. **退款是异步的**
   - 调用退款接口后，不会立即完成
   - 需要等待第三方平台处理
   - 通过回调接口接收结果

3. **需要实现两个接口**
   - 主动调用：我们调用第三方的退款接口
   - 被动接收：第三方调用我们的回调接口

4. **退款金额原路返回**
   - 用户用支付宝支付，退款到支付宝
   - 用户用微信支付，退款到微信
   - 由第三方平台自动处理

---

## 集成第三方支付后的完整实现

### 1. 支付流程

```java
@Override
@Transactional
public Result<Object> payOrder(Map<String, Object> data) {
    // ... 前面的验证逻辑 ...
    
    // 验证支付方式
    String paymentMethod = (String) data.get("paymentMethod");
    if (!"alipay".equals(paymentMethod) && !"wechat".equals(paymentMethod)) {
        logger.warn("支付订单失败: 不支持的支付方式: {}", paymentMethod);
        return Result.failure(5120); // 不支持的支付方式
    }
    
    // 调用第三方支付接口
    try {
        String payUrl = null;
        if ("alipay".equals(paymentMethod)) {
            // 调用支付宝支付接口
            payUrl = alipayService.createPayment(order.getId(), order.getTotalAmount());
        } else if ("wechat".equals(paymentMethod)) {
            // 调用微信支付接口
            payUrl = wechatPayService.createPayment(order.getId(), order.getTotalAmount());
        }
        
        // 返回支付URL给前端
        Map<String, Object> responseData = new HashMap<>();
        responseData.put("orderId", orderId);
        responseData.put("payUrl", payUrl); // 前端跳转到这个URL进行支付
        
        return Result.success(5007, responseData);
        
    } catch (Exception e) {
        logger.error("调用支付接口失败: orderId={}, error={}", orderId, e.getMessage());
        return Result.failure(5117);
    }
}
```

### 2. 支付回调接口

```java
@PostMapping("/payment/callback")
public String handlePaymentCallback(@RequestBody Map<String, Object> callbackData) {
    try {
        // 1. 验证回调签名（防止伪造）
        if (!paymentService.verifySignature(callbackData)) {
            logger.warn("支付回调签名验证失败");
            return "fail";
        }
        
        // 2. 解析回调数据
        String orderId = (String) callbackData.get("orderId");
        String paymentStatus = (String) callbackData.get("status");
        
        // 3. 查询订单
        Order order = orderMapper.selectById(orderId);
        if (order == null) {
            logger.warn("支付回调: 订单不存在: orderId={}", orderId);
            return "fail";
        }
        
        // 4. 更新订单状态
        if ("success".equals(paymentStatus)) {
            order.setStatus(Order.STATUS_PENDING_SHIPMENT); // 待发货
            order.setPaymentTime(new Date());
            orderMapper.updateById(order);
            logger.info("支付成功: orderId={}", orderId);
        }
        
        return "success"; // 返回给第三方平台
        
    } catch (Exception e) {
        logger.error("处理支付回调失败", e);
        return "fail";
    }
}
```

### 3. 退款流程

```java
@Override
@Transactional
public Result<Boolean> processRefund(String id, Map<String, Object> data) {
    // ... 前面的验证逻辑 ...
    
    if (approve) {
        // 同意退款
        order.setRefundStatus(2); // 2:已同意，处理中
        order.setUpdateTime(new Date());
        
        int rows = orderMapper.updateById(order);
        if (rows > 0) {
            // 调用第三方支付平台的退款接口
            try {
                if ("alipay".equals(order.getPaymentMethod())) {
                    // 调用支付宝退款接口
                    alipayService.refund(order.getId(), order.getTotalAmount(), order.getRefundReason());
                } else if ("wechat".equals(order.getPaymentMethod())) {
                    // 调用微信退款接口
                    wechatPayService.refund(order.getId(), order.getTotalAmount(), order.getRefundReason());
                }
                
                logger.info("退款请求已提交: orderId={}, amount={}", id, order.getTotalAmount());
                return Result.success(5012, true); // 已同意退款申请，等待处理
                
            } catch (Exception e) {
                logger.error("调用退款接口失败: orderId={}, error={}", id, e.getMessage());
                // 退款接口调用失败，回滚订单状态
                order.setRefundStatus(1); // 恢复为申请中
                orderMapper.updateById(order);
                return Result.failure(5131);
            }
        }
    }
    
    // ... 拒绝退款的逻辑 ...
}
```

### 4. 退款回调接口

```java
@PostMapping("/payment/refund/callback")
public String handleRefundCallback(@RequestBody Map<String, Object> callbackData) {
    try {
        // 1. 验证回调签名
        if (!paymentService.verifySignature(callbackData)) {
            logger.warn("退款回调签名验证失败");
            return "fail";
        }
        
        // 2. 解析回调数据
        String orderId = (String) callbackData.get("orderId");
        String refundStatus = (String) callbackData.get("status");
        
        // 3. 查询订单
        Order order = orderMapper.selectById(orderId);
        if (order == null) {
            logger.warn("退款回调: 订单不存在: orderId={}", orderId);
            return "fail";
        }
        
        // 4. 更新订单状态
        if ("success".equals(refundStatus)) {
            order.setStatus(Order.STATUS_REFUNDED); // 已退款
            order.setRefundProcessTime(new Date());
            orderMapper.updateById(order);
            logger.info("退款成功: orderId={}", orderId);
        } else {
            order.setRefundStatus(3); // 退款失败
            orderMapper.updateById(order);
            logger.warn("退款失败: orderId={}", orderId);
        }
        
        return "success"; // 返回给第三方平台
        
    } catch (Exception e) {
        logger.error("处理退款回调失败", e);
        return "fail";
    }
}
```

---

## 总结

### 余额支付

| 问题 | 答案 |
|------|------|
| 第三方接口能解决余额不足问题吗？ | ✅ 能，但仅限于第三方平台的余额（支付宝余额、微信零钱） |
| 第三方接口能解决系统内部余额吗？ | ❌ 不能，需要我们自己实现 |
| 当前代码的"balance"是什么？ | 系统内部余额，不是第三方平台余额 |
| 推荐方案 | 移除"balance"，只支持alipay和wechat |

### 退款操作

| 问题 | 答案 |
|------|------|
| 第三方平台会自动退款吗？ | ❌ 不会，需要我们主动调用退款接口 |
| 退款是同步还是异步？ | 异步，需要通过回调接口接收结果 |
| 需要实现几个接口？ | 2个：主动调用退款接口 + 被动接收回调接口 |
| 退款金额去哪里？ | 原路返回（支付宝退到支付宝，微信退到微信） |

### 关键点

1. **余额支付**：第三方接口只能处理第三方平台的余额，不能处理我们系统内部的余额
2. **退款操作**：需要我们主动调用第三方接口，不是第三方自动处理
3. **异步处理**：支付和退款都是异步的，需要实现回调接口
4. **签名验证**：回调接口必须验证签名，防止伪造
